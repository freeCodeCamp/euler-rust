# Project Euler in Rust: 101 to 200
    
Complete the freeCodeCamp Project Euler problems in the Rust programming language using WebAssembly.

## 0

### --description--

If we are presented with the first k terms of a sequence it is impossible to say with certainty the value of the next term, as there are infinitely many polynomial functions that can model the sequence.

As an example, let us consider the sequence of cube numbers. This is defined by the generating function, $u_n = n^3: 1, 8, 27, 64, 125, 216, \ldots$

Suppose we were only given the first two terms of this sequence. Working on the principle that "simple is best" we should assume a linear relationship and predict the next term to be 15 (common difference 7). Even if we were presented with the first three terms, by the same principle of simplicity, a quadratic relationship should be assumed.

We shall define $OP(k, n)$ to be the $n^{th}$ term of the optimum polynomial generating function for the first k terms of a sequence. It should be clear that $OP(k, n)$ will accurately generate the terms of the sequence for $n ≤ k$, and potentially the first incorrect term (FIT) will be $OP(k, k+1)$; in which case we shall call it a bad OP (BOP).

As a basis, if we were only given the first term of sequence, it would be most sensible to assume constancy; that is, for $n ≥ 2, OP(1, n) = u_1$.

Hence we obtain the following OPs for the cubic sequence:

$$\begin{array}{ll}
  OP(1, n) = 1          & 1, {\color{red}1}, 1, 1, \ldots     \\\\
  OP(2, n) = 7n−6       & 1, 8, {\color{red}{15}}, \ldots     \\\\
  OP(3, n) = 6n^2−11n+6 & 1, 8, 27, {\color{red}{58}}, \ldots \\\\
  OP(4, n) = n^3        & 1, 8, 27, 64, 125, \ldots
\end{array}$$

Clearly no BOPs exist for k ≥ 4. By considering the sum of FITs generated by the BOPs (indicated in $\color{red}{red}$ above), we obtain 1 + 15 + 58 = 74. Consider the following tenth degree polynomial generating function:

$$u_n = 1 − n + n^2 − n^3 + n^4 − n^5 + n^6 − n^7 + n^8 − n^9 + n^{10}$$

Find the sum of FITs for the BOPs.

### --tests--

`optimumPolynomial()` should return `37076114526`.

```js
assert.strictEqual(optimumPolynomial(), 37076114526);
```

## 1

### --description--

Three distinct points are plotted at random on a Cartesian plane, for which -1000 ≤ x, y ≤ 1000, such that a triangle is formed.

Consider the following two triangles:

```js
const exampleTriangles = [
  [[-340, 495], [-153, -910], [835, -947]],
  [[-175, 41], [-421, -714], [574, -645]]
];
```

It can be verified that first triangle contains the origin, whereas second triangle does not.

Using the `triangles` array containing coordinates of triangles, find the number of triangles for which the interior contains the origin.

### --tests--

`triangleContainment(exampleTriangles)` should return a number.

```js
assert(typeof triangleContainment(_exampleTriangles) === 'number');
```

`triangleContainment(exampleTriangles)` should return `1`.

```js
assert.strictEqual(triangleContainment(_exampleTriangles), 1);
```

`triangleContainment(testTriangles1)` should return `19`.

```js
assert.strictEqual(triangleContainment(_testTriangles1), 19);
```

`triangleContainment(testTriangles2)` should return `228`.

```js
assert.strictEqual(triangleContainment(_testTriangles2), 228);
```

## 2

### --description--

Let $S(A)$ represent the sum of elements in set A of size n. We shall call it a special sum set if for any two non-empty disjoint subsets, B and C, the following properties are true:

1. $S(B) ≠ S(C)$; that is, sums of subsets cannot be equal.
2. If B contains more elements than C then $S(B) > S(C)$.

If $S(A)$ is minimised for a given n, we shall call it an optimum special sum set. The first five optimum special sum sets are given below.

$$\begin{align}
  & n = 1: \\{1\\} \\\\
  & n = 2: \\{1, 2\\} \\\\
  & n = 3: \\{2, 3, 4\\} \\\\
  & n = 4: \\{3, 5, 6, 7\\} \\\\
  & n = 5: \\{6, 9, 11, 12, 13\\} \\\\
\end{align}$$

It seems that for a given optimum set, $A = \\{a_1, a_2, \ldots, a_n\\}$, the next optimum set is of the form $B = \\{b, a_1 + b, a_2 + b, \ldots, a_n + b\\}$, where b is the "middle" element on the previous row.

By applying this "rule" we would expect the optimum set for $n = 6$ to be $A = \\{11, 17, 20, 22, 23, 24\\}$, with $S(A) = 117$. However, this is not the optimum set, as we have merely applied an algorithm to provide a near optimum set. The optimum set for $n = 6$ is $A = \\{11, 18, 19, 20, 22, 25\\}$, with $S(A) = 115$ and corresponding set string: `111819202225`.

Given that A is an optimum special sum set for $n = 7$, find its set string.

**Note:** This problem is related to Problem 105 and Problem 106.

### --tests--

`optimumSpecialSumSet()` should return the string `20313839404245`.

```js
assert.strictEqual(optimumSpecialSumSet(), '20313839404245');
```

## 3

### --description--

The Fibonacci sequence is defined by the recurrence relation:

$F_n = F_{n − 1} + F_{n − 2}$, where $F_1 = 1$ and $F_2 = 1$

It turns out that $F_{541}$, which contains 113 digits, is the first Fibonacci number for which the last nine digits are 1 - 9 pandigital (contain all the digits 1 to 9, but not necessarily in order). And $F_{2749}$, which contains 575 digits, is the first Fibonacci number for which the first nine digits are 1 - 9 pandigital.

Given that $F_k$ is the first Fibonacci number for which the first nine digits AND the last nine digits are 1 - 9 pandigital, find `k`.

### --tests--

`pandigitalFibonacciEnds()` should return `329468`.

```js
assert.strictEqual(pandigitalFibonacciEnds(), 329468);
```

## 4

### --description--

Let $S(A)$ represent the sum of elements in set A of size n. We shall call it a special sum set if for any two non-empty disjoint subsets, B and C, the following properties are true:

1. $S(B) ≠ S(C)$; that is, sums of subsets cannot be equal.
2. If B contains more elements than C then $S(B) > S(C)$.

For example, {81, 88, 75, 42, 87, 84, 86, 65} is not a special sum set because 65 + 87 + 88 = 75 + 81 + 84, whereas {157, 150, 164, 119, 79, 159, 161, 139, 158} satisfies both rules for all possible subset pair combinations and $S(A) = 1286$.

Using `sets`, an array with one-hundred sets, containing seven to twelve elements (the two examples given above are the first two sets), identify all the special sum sets, $A_1, A_2, \ldots, A_k$, and find the value of $(A_1) + S(A_2) + \cdots + S(A_k)$.

**Note:** This problem is related to Problem 103 and Problem 106.

### --tests--

`testingSpecialSubsetSums(testSets)` should return `73702`.

```js
assert.strictEqual(testingSpecialSubsetSums(_testSets), 73702);
```

## 5

### --description--

Let $S(A)$ represent the sum of elements in set A of size n. We shall call it a special sum set if for any two non-empty disjoint subsets, B and C, the following properties are true:

1. $S(B) ≠ S(C)$; that is, sums of subsets cannot be equal.
2. If B contains more elements than C then $S(B) > S(C)$.

For this problem we shall assume that a given set contains n strictly increasing elements and it already satisfies the second rule.

Surprisingly, out of the 25 possible subset pairs that can be obtained from a set for which n = 4, only 1 of these pairs need to be tested for equality (first rule). Similarly, when n = 7, only 70 out of the 966 subset pairs need to be tested.

For n = 12, how many of the 261625 subset pairs that can be obtained need to be tested for equality?

**Note:** This problem is related to Problem 103 and Problem 105.

### --tests--

`subsetSumsMetaTesting()` should return `21384`.

```js
assert.strictEqual(subsetSumsMetaTesting(), 21384);
```

## 6

### --description--

The following undirected network consists of seven vertices and twelve edges with a total weight of 243.

<img class="img-responsive center-block" alt="Network with seven vertices and twelve edges" src="https://cdn.freecodecamp.org/curriculum/project-euler/minimal-network-1.png" style="background-color: white; padding: 10px;">

The same network can be represented by the matrix below.

|   | A  | B  | C  | D  | E  | F  | G  |
|---|----|----|----|----|----|----|----|
| A | -  | 16 | 12 | 21 | -  | -  | -  |
| B | 16 | -  | -  | 17 | 20 | -  | -  |
| C | 12 | -  | -  | 28 | -  | 31 | -  |
| D | 21 | 17 | 28 | -  | 18 | 19 | 23 |
| E | -  | 20 | -  | 18 | -  | -  | 11 |
| F | -  | -  | 31 | 19 | -  | -  | 27 |
| G | -  | -  | -  | 23 | 11 | 27 | -  |


However, it is possible to optimise the network by removing some edges and still ensure that all points on the network remain connected. The network which achieves the maximum saving is shown below. It has a weight of 93, representing a saving of 243 − 93 = 150 from the original network.

<img class="img-responsive center-block" alt="Network with seven vertices and left six edges: AB, BD, CA, DE, DF, EG" src="https://cdn.freecodecamp.org/curriculum/project-euler/minimal-network-2.png" style="background-color: white; padding: 10px;">

Using `network`, an 2D array representing network in matrix form, find the maximum saving which can be achieved by removing redundant edges whilst ensuring that the network remains connected. Vertices not having connection will be represented with `-1`.

### --tests--

`minimalNetwork(testNetwork)` should return `259679`.

```js
assert.strictEqual(minimalNetwork(_testNetwork), 259679);
```

## 7

### --description--

In the following equation x, y, and n are positive integers.

$$\frac{1}{x} + \frac{1}{y} = \frac{1}{n}$$

For `n` = 4 there are exactly three distinct solutions:

$$\begin{align}
  & \frac{1}{5} + \frac{1}{20} = \frac{1}{4}\\\\
  \\\\
  & \frac{1}{6} + \frac{1}{12} = \frac{1}{4}\\\\
  \\\\
  & \frac{1}{8} + \frac{1}{8} = \frac{1}{4}
\end{align}$$

What is the least value of `n` for which the number of distinct solutions exceeds one-thousand?

### --tests--

`diophantineOne()` should return `180180`.

```js
assert.strictEqual(diophantineOne(), 180180);
```

## 8

### --description--

In the game of darts a player throws three darts at a target board which is split into twenty equal sized sections numbered one to twenty.

<img class="img-responsive center-block" alt="Darts board" src="https://cdn.freecodecamp.org/curriculum/project-euler/darts.png" style="background-color: white; padding: 10px;">

The score of a dart is determined by the number of the region that the dart lands in. A dart landing outside the red/green outer ring scores zero. The black and cream regions inside this ring represent single scores. However, the red/green outer ring and middle ring score double and treble scores respectively.

At the center of the board are two concentric circles called the bull region, or bulls-eye. The outer bull is worth 25 points and the inner bull is a double, worth 50 points.

There are many variations of rules but in the most popular game the players will begin with a score of 301 or 501 and the first player to reduce their running total to zero is a winner. However, it is normal to play a "doubles out" system, which means that the player must land a double (including the double bulls-eye at the center of the board) on their final dart to win; any other dart that would reduce their running total to one or lower means the score for that set of three darts is "bust".

When a player is able to finish on their current score it is called a "checkout" and the highest checkout is 170: T20 T20 D25 (two treble 20s and double bull). There are exactly eleven distinct ways to checkout on a score of 6:

$$\begin{array}
  \text{D3} &    &    \\\\
  D1        & D2 &    \\\\
  S2        & D2 &    \\\\
  D2        & D1 &    \\\\
  S4        & D1 &    \\\\
  S1        & S1 & D2 \\\\
  S1        & T1 & D1 \\\\
  S1        & S3 & D1 \\\\
  D1        & D1 & D1 \\\\
  D1        & S2 & D1 \\\\
  S2        & S2 & D1
\end{array}$$

Note that D1 D2 is considered different from D2 D1 as they finish on different doubles. However, the combination S1 T1 D1 is considered the same as T1 S1 D1. In addition, we shall not include misses in considering combinations; for example, D3 is the same as 0 D3 and 0 0 D3. Incredibly there are 42336 distinct ways of checking out in total. How many distinct ways can a player checkout with a score less than 100?

### --tests--

`darts()` should return `38182`.

```js
assert.strictEqual(darts(), 38182);
```

## 9

### --description--

In the following equation x, y, and n are positive integers.

$$\frac{1}{x} + \frac{1}{y} = \frac{1}{n}$$

It can be verified that when `n` = 1260 there are 113 distinct solutions and this is the least value of `n` for which the total number of distinct solutions exceeds one hundred.

What is the least value of `n` for which the number of distinct solutions exceeds four million?

**Note:** This problem is a much more difficult version of Problem 108 and as it is well beyond the limitations of a brute force approach it requires a clever implementation.

### --tests--

`diophantineTwo()` should return `9350130049860600`.

```js
assert.strictEqual(diophantineTwo(), 9350130049860600);
```

## 10

### --description--

Considering 4-digit primes containing repeated digits it is clear that they cannot all be the same: 1111 is divisible by 11, 2222 is divisible by 22, and so on. But there are nine 4-digit primes containing three ones:

$$1117, 1151, 1171, 1181, 1511, 1811, 2111, 4111, 8111$$

We shall say that $M(n, d)$ represents the maximum number of repeated digits for an n-digit prime where d is the repeated digit, $N(n, d)$ represents the number of such primes, and $S(n, d)$ represents the sum of these primes.

So $M(4, 1) = 3$ is the maximum number of repeated digits for a 4-digit prime where one is the repeated digit, there are $N(4, 1) = 9$ such primes, and the sum of these primes is $S(4, 1) = 22275$. It turns out that for d = 0, it is only possible to have $M(4, 0) = 2$ repeated digits, but there are $N(4, 0) = 13$ such cases.

In the same way we obtain the following results for 4-digit primes.

| Digit, d | $M(4, d)$ | $N(4, d)$ | $S(4, d)$ |
|----------|-----------|-----------|-----------|
| 0        | 2         | 13        | 67061     |
| 1        | 3         | 9         | 22275     |
| 2        | 3         | 1         | 2221      |
| 3        | 3         | 12        | 46214     |
| 4        | 3         | 2         | 8888      |
| 5        | 3         | 1         | 5557      |
| 6        | 3         | 1         | 6661      |
| 7        | 3         | 9         | 57863     |
| 8        | 3         | 1         | 8887      |
| 9        | 3         | 7         | 48073     |

For d = 0 to 9, the sum of all $S(4, d)$ is 273700. Find the sum of all $S(10, d)$.

### --tests--

`primesWithRuns()` should return `612407567715`.

```js
assert.strictEqual(primesWithRuns(), 612407567715);
```

## 11

### --description--

Working from left-to-right if no digit is exceeded by the digit to its left it is called an increasing number; for example, 134468.

Similarly if no digit is exceeded by the digit to its right it is called a decreasing number; for example, 66420.

We shall call a positive integer that is neither increasing nor decreasing a "bouncy" number; for example, 155349.

Clearly there cannot be any bouncy numbers below one-hundred, but just over half of the numbers below one-thousand (525) are bouncy. In fact, the least number for which the proportion of bouncy numbers first reaches 50% is 538.

Surprisingly, bouncy numbers become more and more common and by the time we reach 21780 the proportion of bouncy numbers is equal to 90%.

Find the least number for which the proportion of bouncy numbers is exactly 99%.

### --tests--

`bouncyNumbers()` should return `1587000`.

```js
assert.strictEqual(bouncyNumbers(), 1587000);
```

## 12

### --description--

Working from left-to-right if no digit is exceeded by the digit to its left it is called an increasing number; for example, 134468.

Similarly if no digit is exceeded by the digit to its right it is called a decreasing number; for example, 66420.

We shall call a positive integer that is neither increasing nor decreasing a "bouncy" number; for example, 155349.

As n increases, the proportion of bouncy numbers below n increases such that there are only 12951 numbers below one-million that are not bouncy and only 277032 non-bouncy numbers below ${10}^{10}$.

How many numbers below a googol (${10}^{100}$) are not bouncy?

### --tests--

`nonBouncyNumbers()` should return `51161058134250`.

```js
assert.strictEqual(nonBouncyNumbers(), 51161058134250);
```

## 13

### --description--

A row measuring seven units in length has red blocks with a minimum length of three units placed on it, such that any two red blocks (which are allowed to be different lengths) are separated by at least one black square. There are exactly seventeen ways of doing this.

<img class="img-responsive center-block" alt="Possible ways of placing block with a minimum length of three units, on a row with length of seven units" src="https://cdn.freecodecamp.org/curriculum/project-euler/counting-block-combinations-i.png" style="background-color: white; padding: 10px;">

How many ways can a row measuring fifty units in length be filled?

**Note:** Although the example above does not lend itself to the possibility, in general it is permitted to mix block sizes. For example, on a row measuring eight units in length you could use red (3), black (1), and red (4).

### --tests--

`countingBlockOne()` should return `16475640049`.

```js
assert.strictEqual(countingBlockOne(), 16475640049);
```

## 14

### --description--

A row measuring `n` units in length has red blocks with a minimum length of `m` units placed on it, such that any two red blocks (which are allowed to be different lengths) are separated by at least one black square.

Let the fill-count function, $F(m, n)$, represent the number of ways that a row can be filled.

For example, $F(3, 29) = 673135$ and $F(3, 30) = 1089155$.

That is, for m = 3, it can be seen that n = 30 is the smallest value for which the fill-count function first exceeds one million.

In the same way, for m = 10, it can be verified that $F(10, 56) = 880711$ and $F(10, 57) = 1148904$, so n = 57 is the least value for which the fill-count function first exceeds one million.

For m = 50, find the least value of `n` for which the fill-count function first exceeds one million.

**Note:** This is a more difficult version of Problem 114.

### --tests--

`countingBlockTwo()` should return `168`.

```js
assert.strictEqual(countingBlockTwo(), 168);
```

## 15

### --description--

A row of five black square tiles is to have a number of its tiles replaced with coloured oblong tiles chosen from red (length two), green (length three), or blue (length four).

If red tiles are chosen there are exactly seven ways this can be done.

<img class="img-responsive center-block" alt="Possible ways to placing red oblong on a row with length of five units" src="https://cdn.freecodecamp.org/curriculum/project-euler/red-green-or-blue-tiles-1.png" style="background-color: white; padding: 10px;">

If green tiles are chosen there are three ways.

<img class="img-responsive center-block" alt="Possible ways of placing green oblong on a row with length of five units" src="https://cdn.freecodecamp.org/curriculum/project-euler/red-green-or-blue-tiles-2.png" style="background-color: white; padding: 10px;">

And if blue tiles are chosen there are two ways.

<img class="img-responsive center-block" alt="Possible ways of placing blue oblong on a row with length of five units" src="https://cdn.freecodecamp.org/curriculum/project-euler/red-green-or-blue-tiles-3.png" style="background-color: white; padding: 10px;">

Assuming that colors cannot be mixed there are 7 + 3 + 2 = 12 ways of replacing the black tiles in a row measuring five units in length. How many different ways can the black tiles in a row measuring fifty units in length be replaced if colors cannot be mixed and at least one colored tile must be used?

**Note:** This is related to Problem 117.

### --tests--

`redGreenBlueOne()` should return `20492570929`.

```js
assert.strictEqual(redGreenBlueOne(), 20492570929);
```

## 16

### --description--

Using a combination of black square tiles and oblong tiles chosen from: red tiles measuring two units, green tiles measuring three units, and blue tiles measuring four units, it is possible to tile a row measuring five units in length in exactly fifteen different ways.

<img class="img-responsive center-block" alt="Possible ways of placing red, green and blue oblongs on a row with length of five units" src="https://cdn.freecodecamp.org/curriculum/project-euler/red-green-and-blue-tiles.png" style="background-color: white; padding: 10px;">

How many ways can a row measuring fifty units in length be tiled?

**Note**: This is related to Problem 116.

### --tests--

`redGreenBlueTilesTwo()` should return `100808458960497`.

```js
assert.strictEqual(redGreenBlueTilesTwo(), 100808458960497);
```

## 17

### --description--

Using all of the digits 1 through 9 and concatenating them freely to form decimal integers, different sets can be formed. Interestingly with the set $\\{2, 5, 47, 89, 631\\}$, all of the elements belonging to it are prime.

How many distinct sets containing each of the digits one through nine exactly once contain only prime elements?

### --tests--

`pandigitalPrimeSets()` should return `44680`.

```js
assert.strictEqual(pandigitalPrimeSets(), 44680);
```

## 18

### --description--

The number 512 is interesting because it is equal to the sum of its digits raised to some power: $5 + 1 + 2 = 8$, and $8^3 = 512$. Another example of a number with this property is $614656 = 28^4$.

We shall define $a_n$ to be the $n-th$ term of this sequence and insist that a number must contain at least two digits to have a sum.

You are given that $a_2 = 512$ and $a_{10} = 614656$.

Find $a_{30}$.

### --tests--

`digitPowerSum()` should return `248155780267521`.

```js
assert.strictEqual(digitPowerSum(), 248155780267521);
```

## 19

### --description--

Let `r` be the remainder when ${(a − 1)}^n + {(a + 1)}^n$ is divided by $a^2$.

For example, if $a = 7$ and $n = 3$, then $r = 42: 6^3 + 8^3 = 728 ≡ 42 \\ \text{mod}\\ 49$. And as `n` varies, so too will `r`, but for $a = 7$ it turns out that $r_{max} = 42$.

For $3 ≤ a ≤ 1000$, find $\sum{r}_{max}$.

### --tests--

`squareRemainders()` should return `333082500`.

```js
assert.strictEqual(squareRemainders(), 333082500);
```

## 20

### --description--

A bag contains one red disc and one blue disc. In a game of chance a player takes a disc at random and its colour is noted. After each turn the disc is returned to the bag, an extra red disc is added, and another disc is taken at random.

The player pays £1 to play and wins if they have taken more blue discs than red discs at the end of the game.

If the game is played for four turns, the probability of a player winning is exactly 11/120, and so the maximum prize fund the banker should allocate for winning in this game would be £10 before they would expect to incur a loss. Note that any payout will be a whole number of pounds and also includes the original £1 paid to play the game, so in the example given the player actually wins £9.

Find the maximum prize fund that should be allocated to a single game in which fifteen turns are played.

### --tests--

`discGamePrize()` should return `2269`.

```js
assert.strictEqual(discGamePrize(), 2269);
```

## 21

### --description--

The most naive way of computing $n^{15}$ requires fourteen multiplications:

$$n × n × \ldots × n = n^{15}$$

But using a "binary" method you can compute it in six multiplications:

$$\begin{align}
  & n × n = n^2\\\\
  & n^2 × n^2 = n^4\\\\
  & n^4 × n^4 = n^8\\\\
  & n^8 × n^4 = n^{12}\\\\
  & n^{12} × n^2 = n^{14}\\\\
  & n^{14} × n = n^{15}
\end{align}$$

However it is yet possible to compute it in only five multiplications:

$$\begin{align}
  & n × n = n^2\\\\
  & n^2 × n = n^3\\\\
  & n^3 × n^3 = n^6\\\\
  & n^6 × n^6 = n^{12}\\\\
  & n^{12} × n^3 = n^{15}
\end{align}$$

We shall define $m(k)$ to be the minimum number of multiplications to compute $n^k$; for example $m(15) = 5$.

For $1 ≤ k ≤ 200$, find $\sum{m(k)}$.

### --tests--

`efficientExponentiation()` should return `1582`.

```js
assert.strictEqual(efficientExponentiation(), 1582);
```

## 22

### --description--

Let $p_n$ be the $n$th prime: 2, 3, 5, 7, 11, ..., and let $r$ be the remainder when ${(p_n−1)}^n + {(p_n+1)}^n$ is divided by ${p_n}^2$.

For example, when $n = 3, p_3 = 5$, and $4^3 + 6^3 = 280 ≡ 5\\ mod\\ 25$.

The least value of $n$ for which the remainder first exceeds $10^9$ is 7037.

Find the least value of $n$ for which the remainder first exceeds $10^{10}$.

### --tests--

`primeSquareRemainders()` should return `21035`.

```js
assert.strictEqual(primeSquareRemainders(), 21035);
```

## 23

### --description--

The radical of $n$, $rad(n)$, is the product of the distinct prime factors of $n$. For example, $504 = 2^3 × 3^2 × 7$, so $rad(504) = 2 × 3 × 7 = 42$.

If we calculate $rad(n)$ for $1 ≤ n ≤ 10$, then sort them on $rad(n)$, and sorting on $n$ if the radical values are equal, we get:

<div style="text-align: center;">
  <table cellpadding="2" cellspacing="0" border="0" align="center">
    <tbody>
      <tr>
        <td colspan="2">$Unsorted$</td>
        <td></td>
        <td colspan="3">$Sorted$</td>
      </tr>
      <tr>
        <td>$n$</td>
        <td>$rad(n)$</td>
        <td></td>
        <td>$n$</td>
        <td>$rad(n)$</td>
        <td>$k$</td>
      </tr>
      <tr>
        <td>1</td>
        <td>1</td>
        <td></td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
      </tr>
      <tr>
        <td>2</td>
        <td>2</td>
        <td></td>
        <td>2</td>
        <td>2</td>
        <td>2</td>
      </tr>
      <tr>
        <td>3</td>
        <td>3</td>
        <td></td>
        <td>4</td>
        <td>2</td>
        <td>3</td>
      </tr>
      <tr>
        <td>4</td>
        <td>2</td>
        <td></td>
        <td>8</td>
        <td>2</td>
        <td>4</td>
      </tr>
      <tr>
        <td>5</td>
        <td>5</td>
        <td></td>
        <td>3</td>
        <td>3</td>
        <td>5</td>
      </tr>
      <tr>
        <td>6</td>
        <td>6</td>
        <td></td>
        <td>9</td>
        <td>3</td>
        <td>6</td>
      </tr>
      <tr>
        <td>7</td>
        <td>7</td>
        <td></td>
        <td>5</td>
        <td>5</td>
        <td>7</td>
      </tr>
      <tr>
        <td>8</td>
        <td>2</td>
        <td></td>
        <td>6</td>
        <td>6</td>
        <td>8</td>
      </tr>
      <tr>
        <td>9</td>
        <td>3</td>
        <td></td>
        <td>7</td>
        <td>7</td>
        <td>9</td>
      </tr>
      <tr>
        <td>10</td>
        <td>10</td>
        <td></td>
        <td>10</td>
        <td>10</td>
        <td>10</td>
      </tr>
    </tbody>
  </table>
</div><br>

Let $E(k)$ be the $k$th element in the sorted $n$ column; for example, $E(4) = 8$ and $E(6) = 9$. If $rad(n)$ is sorted for $1 ≤ n ≤ 100000$, find $E(10000)$.

### --tests--

`orderedRadicals()` should return `21417`.

```js
assert.strictEqual(orderedRadicals(), 21417);
```

## 24

### --description--

The palindromic number 595 is interesting because it can be written as the sum of consecutive squares: $6^2 + 7^2 + 8^2 + 9^2 + 10^2 + 11^2 + 12^2$.

There are exactly eleven palindromes below one-thousand that can be written as consecutive square sums, and the sum of these palindromes is 4164. Note that $1 = 0^2 + 1^2$ has not been included as this problem is concerned with the squares of positive integers.

Find the sum of all the numbers less than the  `limit`  that are both palindromic and can be written as the sum of consecutive squares.

### --tests--
`palindromicSums(100000000)` should return `2906969179`.

```js

assert.strictEqual(palindromicSums(100000000), 2906969179);

```

`palindromicSums(100)` should return `137`.

```js
assert.strictEqual(palindromicSums(100), 137);
```

`palindromicSums(1000)` should return `4164`.

```js
assert.strictEqual(palindromicSums(1000),4164);
```

## 25

### --description--

The minimum number of cubes to cover every visible face on a cuboid measuring 3 x 2 x 1 is twenty-two.

<img class="img-responsive center-block" alt="3x2x1 cuboid covered by twenty-two 1x1x1 cubes" src="https://cdn.freecodecamp.org/curriculum/project-euler/cuboid-layers.png" style="background-color: white; padding: 10px;">

If we add a second layer to this solid it would require forty-six cubes to cover every visible face, the third layer would require seventy-eight cubes, and the fourth layer would require one-hundred and eighteen cubes to cover every visible face.

However, the first layer on a cuboid measuring 5 x 1 x 1 also requires twenty-two cubes; similarly, the first layer on cuboids measuring 5 x 3 x 1, 7 x 2 x 1, and 11 x 1 x 1 all contain forty-six cubes.

We shall define $C(n)$ to represent the number of cuboids that contain $n$ cubes in one of its layers. So $C(22) = 2$, $C(46) = 4$, $C(78) = 5$, and $C(118) = 8$.

It turns out that 154 is the least value of $n$ for which $C(n) = 10$.

Find the least value of $n$ for which $C(n) = 1000$.

### --tests--

`cuboidLayers()` should return `18522`.

```js
assert.strictEqual(cuboidLayers(), 18522);
```

## 26

### --description--

The radical of $n$, $rad(n)$, is the product of distinct prime factors of $n$. For example, $504 = 2^3 × 3^2 × 7$, so $rad(504) = 2 × 3 × 7 = 42$.

We shall define the triplet of positive integers (a, b, c) to be an abc-hit if:

1. $GCD(a, b) = GCD(a, c) = GCD(b, c) = 1$
2. $a &lt; b$
3. $a + b = c$
4. $rad(abc) &lt; c$

For example, (5, 27, 32) is an abc-hit, because:

1. $GCD(5, 27) = GCD(5, 32) = GCD(27, 32) = 1$
2. $5 &lt; 27$
3. $5 + 27 = 32$
4. $rad(4320) = 30 &lt; 32$

It turns out that abc-hits are quite rare and there are only thirty-one abc-hits for $c &lt; 1000$, with $\sum{c} = 12523$.

Find $\sum{c}$ for $c &lt; 120000$.

### --tests--

`abcHits()` should return `18407904`.

```js
assert.strictEqual(abcHits(), 18407904);
```

## 27

### --description--

A hexagonal tile with number 1 is surrounded by a ring of six hexagonal tiles, starting at "12 o'clock" and numbering the tiles 2 to 7 in an anti-clockwise direction.

New rings are added in the same fashion, with the next rings being numbered 8 to 19, 20 to 37, 38 to 61, and so on. The diagram below shows the first three rings.

<img class="img-responsive center-block" alt="three first rings of arranged hexagonal tiles with numbers 1 to 37, and with highlighted tiles 8 and 17" src="https://cdn.freecodecamp.org/curriculum/project-euler/hexagonal-tile-differences.png" style="background-color: white; padding: 10px;">

By finding the difference between tile $n$ and each of its six neighbours we shall define $PD(n)$ to be the number of those differences which are prime.

For example, working clockwise around tile 8 the differences are 12, 29, 11, 6, 1, and 13. So $PD(8) = 3$.

In the same way, the differences around tile 17 are 1, 17, 16, 1, 11, and 10, hence $PD(17) = 2$.

It can be shown that the maximum value of $PD(n)$ is $3$.

If all of the tiles for which $PD(n) = 3$ are listed in ascending order to form a sequence, the 10th tile would be 271.

Find the 2000th tile in this sequence.

### --tests--

`hexagonalTile(10)` should return `271`.

```js
assert.strictEqual(hexagonalTile(10), 271);
```

`hexagonalTile(2000)` should return `14516824220`.

```js
assert.strictEqual(hexagonalTile(2000), 14516824220);
```

## 28

### --description--

A number consisting entirely of ones is called a repunit. We shall define $R(k)$ to be a repunit of length $k$; for example, $R(6) = 111111$.

Given that $n$ is a positive integer and $GCD(n, 10) = 1$, it can be shown that there always exists a value, $k$, for which $R(k)$ is divisible by $n$, and let $A(n)$ be the least such value of $k$; for example, $A(7) = 6$ and $A(41) = 5$.

The least value of $n$ for which $A(n)$ first exceeds ten is 17.

Find the least value of $n$ for which $A(n)$ first exceeds one-million.

### --tests--

`repunitDivisibility()` should return `1000023`.

```js
assert.strictEqual(repunitDivisibility(), 1000023);
```

## 29

### --description--

A number consisting entirely of ones is called a repunit. We shall define $R(k)$ to be a repunit of length $k$; for example, $R(6) = 111111$.

Given that $n$ is a positive integer and $GCD(n, 10) = 1$, it can be shown that there always exists a value, $k$, for which $R(k)$ is divisible by $n$, and let $A(n)$ be the least such value of $k$; for example, $A(7) = 6$ and $A(41) = 5$.

You are given that for all primes, $p > 5$, that $p − 1$ is divisible by $A(p)$. For example, when $p = 41, A(41) = 5$, and 40 is divisible by 5.

However, there are rare composite values for which this is also true; the first five examples being 91, 259, 451, 481, and 703.

Find the sum of the first twenty-five composite values of $n$ for which $GCD(n, 10) = 1$ and $n − 1$ is divisible by $A(n)$.

### --tests--

`compositeRepunit()` should return `149253`.

```js
assert.strictEqual(compositeRepunit(), 149253);
```

## 30

### --description--

There are some prime values, $p$, for which there exists a positive integer, $n$, such that the expression $n^3 + n^{2}p$ is a perfect cube.

For example, when $p = 19,\\ 8^3 + 8^2 × 19 = {12}^3$.

What is perhaps most surprising is that the value of $n$ is unique for each prime with this property, and there are only four such primes below one hundred.

How many primes below one million have this remarkable property?

### --tests--

`primeCubePartnership()` should return `173`.

```js
assert.strictEqual(primeCubePartnership(), 173);
```

## 31

### --description--

A number consisting entirely of ones is called a repunit. We shall define $R(k)$ to be a repunit of length $k$.

For example, $R(10) = 1111111111 = 11 × 41 × 271 × 9091$, and the sum of these prime factors is 9414.

Find the sum of the first forty prime factors of $R({10}^9)$.

### --tests--

`largeRepunitFactors()` should return `843296`.

```js
assert.strictEqual(largeRepunitFactors(), 843296);
```

## 32

### --description--

A number consisting entirely of ones is called a repunit. We shall define $R(k)$ to be a repunit of length $k$; for example, $R(6) = 111111$.

Let us consider repunits of the form $R({10}^n)$.

Although $R(10)$, $R(100)$, or $R(1000)$ are not divisible by 17, $R(10000)$ is divisible by 17. Yet there is no value of n for which $R({10}^n)$ will divide by 19. Remarkably, 11, 17, 41, and 73 are the only four primes below one-hundred that can be a factor of $R({10}^n)$.

Find the sum of all the primes below one-hundred thousand that will never be a factor of $R({10}^n)$.

### --tests--

`repunitNonfactors()` should return `453647705`.

```js
assert.strictEqual(repunitNonfactors(), 453647705);
```

## 33

### --description--

Consider the consecutive primes $p_1 = 19$ and $p_2 = 23$. It can be verified that 1219 is the smallest number such that the last digits are formed by $p_1$ whilst also being divisible by $p_2$.

In fact, with the exception of $p_1 = 3$ and $p_2 = 5$, for every pair of consecutive primes, $p_2 > p_1$, there exist values of $n$ for which the last digits are formed by $p_1$ and $n$ is divisible by $p_2$. Let $S$ be the smallest of these values of $n$.

Find $\sum{S}$ for every pair of consecutive primes with $5 ≤ p_1 ≤ 1000000$.

### --tests--

`primePairConnection()` should return `18613426663617120`.

```js
assert.strictEqual(primePairConnection(), 18613426663617120);
```

## 34

### --description--

Given the positive integers, $x$, $y$, and $z$, are consecutive terms of an arithmetic progression, the least value of the positive integer, $n$, for which the equation, $x^2 − y^2 − z^2 = n$, has exactly two solutions is $n = 27$:

$$34^2 − 27^2 − 20^2 = 12^2 − 9^2 − 6^2 = 27$$

It turns out that $n = 1155$ is the least value which has exactly ten solutions.

How many values of $n$ less than one million have exactly ten distinct solutions?

### --tests--

`sameDifferences()` should return `4989`.

```js
assert.strictEqual(sameDifferences(), 4989);
```

## 35

### --description--

The positive integers, $x$, $y$, and $z$, are consecutive terms of an arithmetic progression. Given that $n$ is a positive integer, the equation, $x^2 − y^2 − z^2 = n$, has exactly one solution when $n = 20$:

$$13^2 − 10^2 − 7^2 = 20$$

In fact, there are twenty-five values of $n$ below one hundred for which the equation has a unique solution.

How many values of $n$ less than fifty million have exactly one solution?

### --tests--

`singletonDifference()` should return `2544559`.

```js
assert.strictEqual(singletonDifference(), 2544559);
```

## 36

### --description--

Consider the infinite polynomial series $A_{F}(x) = xF_1 + x^2F_2 + x^3F_3 + \ldots$, where $F_k$ is the $k$th term in the Fibonacci sequence: $1, 1, 2, 3, 5, 8, \ldots$; that is, $F_k = F_{k − 1} + F_{k − 2}, F_1 = 1$ and $F_2 = 1$.

For this problem we shall be interested in values of $x$ for which $A_{F}(x)$ is a positive integer.

Surprisingly

$$\begin{align}
A_F(\frac{1}{2}) & = (\frac{1}{2}) × 1 + {(\frac{1}{2})}^2 × 1 + {(\frac{1}{2})}^3 × 2 + {(\frac{1}{2})}^4 × 3 + {(\frac{1}{2})}^5 × 5 + \cdots \\\\
                 & = \frac{1}{2} + \frac{1}{4} + \frac{2}{8} + \frac{3}{16} + \frac{5}{32} + \cdots \\\\
                 & = 2
\end{align}$$

The corresponding values of $x$ for the first five natural numbers are shown below.

| $x$                       | $A_F(x)$ |
|---------------------------|----------|
| $\sqrt{2} − 1$            | $1$      |
| $\frac{1}{2}$             | $2$      |
| $\frac{\sqrt{13} − 2}{3}$ | $3$      |
| $\frac{\sqrt{89} − 5}{8}$ | $4$      |
| $\frac{\sqrt{34} − 3}{5}$ | $5$      |

We shall call $A_F(x)$ a golden nugget if $x$ is rational, because they become increasingly rarer; for example, the 10th golden nugget is 74049690.

Find the 15th golden nugget.

### --tests--

`goldenNugget()` should return `1120149658760`.

```js
assert.strictEqual(goldenNugget(), 1120149658760);
```

## 37

### --description--

Consider the isosceles triangle with base length, $b = 16$, and legs, $L = 17$.

<img class="img-responsive center-block" alt="isosceles triangle with edges named as L - two edges with the same length and base of the triangle as b; and height of the triangle - h from the base of the triangle to the angle between L edges" src="https://cdn.freecodecamp.org/curriculum/project-euler/special-isosceles-triangles.png" style="background-color: white; padding: 10px;">

By using the Pythagorean theorem, it can be seen that the height of the triangle, $h = \sqrt{{17}^2 − 8^2} = 15$, which is one less than the base length.

With $b = 272$ and $L = 305$, we get $h = 273$, which is one more than the base length, and this is the second smallest isosceles triangle with the property that $h = b ± 1$.

Find $\sum{L}$ for the twelve smallest isosceles triangles for which $h = b ± 1$ and $b$, $L$ are positive integers.

### --tests--

`isoscelesTriangles()` should return `1118049290473932`.

```js
assert.strictEqual(isoscelesTriangles(), 1118049290473932);
```

## 38

### --description--

Let (a, b, c) represent the three sides of a right angle triangle with integral length sides. It is possible to place four such triangles together to form a square with length c.

For example, (3, 4, 5) triangles can be placed together to form a 5 by 5 square with a 1 by 1 hole in the middle and it can be seen that the 5 by 5 square can be tiled with twenty-five 1 by 1 squares.

<img class="img-responsive center-block" alt="two 5 x 5 squares: one with four 3x4x5 triangles placed to create 1x1 hole in the middle; second with twenty-five 1x1 squares" src="https://cdn.freecodecamp.org/curriculum/project-euler/pythagorean-tiles.png" style="background-color: white; padding: 10px;">

However, if (5, 12, 13) triangles were used, the hole would measure 7 by 7. These 7 by 7 squares could not be used to tile the 13 by 13 square.

Given that the perimeter of the right triangle is less than one-hundred million, how many Pythagorean triangles would allow such a tiling to occur?

### --tests--

`pythagoreanTiles()` should return `10057761`.

```js
assert.strictEqual(pythagoreanTiles(), 10057761);
```

## 39

### --description--

Consider the infinite polynomial series $A_G(x) = xG_1 + x^2G_2 + x^3G_3 + \cdots$, where $G_k$ is the $k$th term of the second order recurrence relation $G_k = G_{k − 1} + G_{k − 2}, G_1 = 1$ and $G_2 = 4$; that is, $1, 4, 5, 9, 14, 23, \ldots$.

For this problem we shall be concerned with values of $x$ for which $A_G(x)$ is a positive integer.

The corresponding values of $x$ for the first five natural numbers are shown below.

| $x$                         | $A_G(x)$ |
|-----------------------------|----------|
| $\frac{\sqrt{5} − 1}{4}$    | $1$      |
| $\frac{2}{5}$               | $2$      |
| $\frac{\sqrt{22} − 2}{6}$   | $3$      |
| $\frac{\sqrt{137} − 5}{14}$ | $4$      |
| $\frac{1}{2}$               | $5$      |

We shall call $A_G(x)$ a golden nugget if $x$ is rational because they become increasingly rarer; for example, the 20th golden nugget is 211345365. Find the sum of the first thirty golden nuggets.

### --tests--

`modifiedGoldenNuggets()` should return `5673835352990`

```js
assert.strictEqual(modifiedGoldenNuggets(), 5673835352990);
```

## 40

### --description--

A positive integer, $n$, is divided by $d$ and the quotient and remainder are $q$ and $r$ respectively. In addition $d$, $q$, and $r$ are consecutive positive integer terms in a geometric sequence, but not necessarily in that order.

For example, 58 divided by 6 has a quotient of 9 and a remainder of 4. It can also be seen that 4, 6, 9 are consecutive terms in a geometric sequence (common ratio $\frac{3}{2}$).

We will call such numbers, $n$, progressive.

Some progressive numbers, such as 9 and 10404 = ${102}^2$, also happen to be perfect squares. The sum of all progressive perfect squares below one hundred thousand is 124657.

Find the sum of all progressive perfect squares below one trillion (${10}^{12}$).

### --tests--

`progressivePerfectSquares()` should return `878454337159`.

```js
assert.strictEqual(progressivePerfectSquares(), 878454337159);
```

## 41

### --description--

Find the smallest $x + y + z$ with integers $x > y > z > 0$ such that $x + y$, $x − y$, $x + z$, $x − z$, $y + z$, $y − z$ are all perfect squares.

### --tests--

`perfectSquareCollection()` should return `1006193`.

```js
assert.strictEqual(perfectSquareCollection(), 1006193);
```

## 42

### --description--

Let ABC be a triangle with all interior angles being less than 120 degrees. Let X be any point inside the triangle and let $XA = p$, $XC = q$, and $XB = r$.

Fermat challenged Torricelli to find the position of X such that p + q + r was minimised.

Torricelli was able to prove that if equilateral triangles AOB, BNC and AMC are constructed on each side of triangle ABC, the circumscribed circles of AOB, BNC, and AMC will intersect at a single point, T, inside the triangle. Moreover he proved that T, called the Torricelli/Fermat point, minimises $p + q + r$. Even more remarkable, it can be shown that when the sum is minimised, $AN = BM = CO = p + q + r$ and that AN, BM and CO also intersect at T.

<img class="img-responsive center-block" alt="equilateral triangles AOB, BNC and AMC constructed on each side of triangle ABC; with the circumscribed circles of AOB, BNC, and AMC will intersecting at a single point, T, inside the triangle" src="https://cdn.freecodecamp.org/curriculum/project-euler/investigating-the-torricelli-point-of-a-triangle.png" style="background-color: white; padding: 10px;">

If the sum is minimised and a, b, c, p, q and r are all positive integers we shall call triangle ABC a Torricelli triangle. For example, $a = 399$, $b = 455$, $c = 511$ is an example of a Torricelli triangle, with $p + q + r = 784$. Find the sum of all distinct values of $p + q + r ≤ 120000$ for Torricelli triangles.

### --tests--

`sumTorricelliTriangles()` should return `30758397`.

```js
assert.strictEqual(sumTorricelliTriangles(), 30758397);
```

## 43

### --description--

In laser physics, a "white cell" is a mirror system that acts as a delay line for the laser beam. The beam enters the cell, bounces around on the mirrors, and eventually works its way back out.

The specific white cell we will be considering is an ellipse with the equation $4{x}^2 + y^2 = 100$

The section corresponding to $−0.01 ≤ x ≤ +0.01$ at the top is missing, allowing the light to enter and exit through the hole.

<div style="text-align: center">
  <img class="img-responsive center-block" alt="light beam starting at point (0.0, 10.1), and impacting the mirror at point (1.4, -9.6)" src="https://cdn.freecodecamp.org/curriculum/project-euler/investigating-multiple-reflections-of-a-laser-beam-1.png" style="display: inline-block; background-color: white; padding: 10px;">
  <img class="img-responsive center-block" alt="animation with first 10 reflections of the beam" src="https://cdn.freecodecamp.org/curriculum/project-euler/investigating-multiple-reflections-of-a-laser-beam-2.gif" style="display: inline-block; background-color: white; padding: 10px;">
</div><br>

The light beam in this problem starts at the point (0.0, 10.1) just outside the white cell, and the beam first impacts the mirror at (1.4, -9.6).

Each time the laser beam hits the surface of the ellipse, it follows the usual law of reflection "angle of incidence equals angle of reflection." That is, both the incident and reflected beams make the same angle with the normal line at the point of incidence.

In the figure on the left, the red line shows the first two points of contact between the laser beam and the wall of the white cell; the blue line shows the line tangent to the ellipse at the point of incidence of the first bounce.

The slope m of the tangent line at any point (x, y) of the given ellipse is: $m = −4 × \frac{x}{y}$

The normal line is perpendicular to this tangent line at the point of incidence.

The animation on the right shows the first 10 reflections of the beam.

How many times does the beam hit the internal surface of the white cell before exiting?

### --tests--

`laserBeamReflections()` should return `354`.

```js
assert.strictEqual(laserBeamReflections(), 354);
```

## 44

### --description--

Some positive integers $n$ have the property that the sum [ $n + reverse(n)$ ] consists entirely of odd (decimal) digits. For instance, $36 + 63 = 99$ and $409 + 904 = 1313$. We will call such numbers reversible; so 36, 63, 409, and 904 are reversible. Leading zeroes are not allowed in either $n$ or $reverse(n)$.

There are 120 reversible numbers below one-thousand.

How many reversible numbers are there below one-billion (${10}^9$)?

### --tests--

`reversibleNumbers()` should return `608720`.

```js
assert.strictEqual(reversibleNumbers(), 608720);
```

## 45

### --description--

The smallest positive integer $n$ for which the numbers $n^2 + 1$, $n^2 + 3$, $n^2 + 7$, $n^2 + 9$, $n^2 + 13$, and $n^2 + 27$ are consecutive primes is 10. The sum of all such integers $n$ below one-million is 1242490.

What is the sum of all such integers $n$ below 150 million?

### --tests--

`primePattern()` should return `676333270`.

```js
assert.strictEqual(primePattern(), 676333270);
```

## 46

### --description--

In a 3x2 cross-hatched grid, a total of 37 different rectangles could be situated within that grid as indicated in the sketch.

<img class="img-responsive center-block" alt="ways of situating different rectangles within cross-hatched 3x2 grid" src="https://cdn.freecodecamp.org/curriculum/project-euler/rectangles-in-cross-hatched-grids.png" style="background-color: white; padding: 10px;">

There are 5 grids smaller than 3x2, vertical and horizontal dimensions being important, i.e. 1x1, 2x1, 3x1, 1x2 and 2x2. If each of them is cross-hatched, the following number of different rectangles could be situated within those smaller grids:

$$\begin{array}{|c|c|}
\hline
  1 \times 1 & 1  \\\\ \hline
  2 \times 1 & 4  \\\\ \hline
  3 \times 1 & 8  \\\\ \hline
  1 \times 2 & 4  \\\\ \hline
  2 \times 2 & 18 \\\\ \hline
\end{array}$$

Adding those to the 37 of the 3x2 grid, a total of 72 different rectangles could be situated within 3x2 and smaller grids.

How many different rectangles could be situated within 47x43 and smaller grids?

### --tests--

`crossHatchedRectangles()` should return `846910284`.

```js
assert.strictEqual(crossHatchedRectangles(), 846910284);
```

## 47

### --description--

We can easily verify that none of the entries in the first seven rows of Pascal's triangle are divisible by 7:

```markup
            1
          1   1
        1   2   1
      1   3   3   1
    1   4   6   4   1
  1   5   10  10  5   1
1   6   15  20  15  6   1
```

However, if we check the first one hundred rows, we will find that only 2361 of the 5050 entries are not divisible by 7.

# --instructions--

Find the number of entries which are not divisible by 7 in the first one billion (${10}^9$) rows of Pascal's triangle.

### --tests--

`entriesOfPascalsTriangle()` should return `2129970655314432`.

```js
assert.strictEqual(entriesOfPascalsTriangle(), 2129970655314432);
```

## 48

### --description--

Looking at the table below, it is easy to verify that the maximum possible sum of adjacent numbers in any direction (horizontal, vertical, diagonal or anti-diagonal) is $16 (= 8 + 7 + 1)$.

$$\begin{array}{|r|r|r|r|}
  \hline
  −2 &  5 &  3 & 2 \\\\ \hline
   9 & −6 &  5 & 1 \\\\ \hline
   3 &  2 &  7 & 3 \\\\ \hline
  −1 &  8 & −4 & 8 \\\\ \hline
\end{array}$$

Now, let us repeat the search, but on a much larger scale:

First, generate four million pseudo-random numbers using a specific form of what is known as a "Lagged Fibonacci Generator":

For $1 ≤ k ≤ 55$, $s_k = (100003 − 200003k + 300007{k}^3) \\ (modulo\\ 1000000) − 500000$.

For $56 ≤ k ≤ 4000000$, $s_k = (s_{k − 24} + s_{k − 55} + 1000000) \\ (modulo\\ 1000000) − 500000$.

Thus, $s_{10} = −393027$ and $s_{100} = 86613$.

The terms of $s$ are then arranged in a 2000×2000 table, using the first 2000 numbers to fill the first row (sequentially), the next 2000 numbers to fill the second row, and so on.

Finally, find the greatest sum of (any number of) adjacent entries in any direction (horizontal, vertical, diagonal or anti-diagonal).

### --tests--

`maximumSubSequence()` should return `52852124`.

```js
assert.strictEqual(maximumSubSequence(), 52852124);
```

## 49

### --description--

In a triangular array of positive and negative integers, we wish to find a sub-triangle such that the sum of the numbers it contains is the smallest possible.

In the example below, it can be easily verified that the marked triangle satisfies this condition having a sum of −42.

<img class="img-responsive center-block" alt="triangular array, with marked sub-triangle, having sum of -42" src="https://cdn.freecodecamp.org/curriculum/project-euler/searching-a-triangular-array-for-a-sub-triangle-having-minimum-sum.gif" style="background-color: white; padding: 10px;">

We wish to make such a triangular array with one thousand rows, so we generate 500500 pseudo-random numbers $s_k$ in the range $±2^{19}$, using a type of random number generator (known as a Linear Congruential Generator) as follows:

$$\begin{align}
  t := & \\ 0\\\\
  \text{for}\\ & k = 1\\ \text{up to}\\ k = 500500:\\\\
  & t := (615949 × t + 797807)\\ \text{modulo}\\ 2^{20}\\\\
  & s_k := t − 219\\\\
\end{align}$$

Thus: $s_1 = 273519$, $s_2 = −153582$, $s_3 = 450905$ etc.

Our triangular array is then formed using the pseudo-random numbers thus:

$$
s_1 \\\\
s_2\\;s_3 \\\\
s_4\\; s_5\\; s_6 \\\\
s_7\\; s_8\\; s_9\\; s_{10} \\\\
\ldots
$$

Sub-triangles can start at any element of the array and extend down as far as we like (taking-in the two elements directly below it from the next row, the three elements directly below from the row after that, and so on).

The "sum of a sub-triangle" is defined as the sum of all the elements it contains.

Find the smallest possible sub-triangle sum.

### --tests--

`smallestSubTriangleSum()` should return `-271248680`.

```js
assert.strictEqual(smallestSubTriangleSum(), -271248680);
```

## 50

### --description--

A printing shop runs 16 batches (jobs) every week and each batch requires a sheet of special colour-proofing paper of size A5.

Every Monday morning, the foreman opens a new envelope, containing a large sheet of the special paper with size A1.

He proceeds to cut it in half, thus getting two sheets of size A2. Then he cuts one of them in half to get two sheets of size A3 and so on until he obtains the A5-size sheet needed for the first batch of the week.

All the unused sheets are placed back in the envelope.

<img class="img-responsive center-block" alt="A1-size sheet split into: A2, A3, A4 and two A5 sheets" src="https://cdn.freecodecamp.org/curriculum/project-euler/paper-sheets-of-standard-sizes-an-expected-value-problem.png" style="background-color: white; padding: 10px;">

At the beginning of each subsequent batch, he takes one sheet of paper from the envelope at random. If it is of size A5, he uses it. If it is larger, he repeats the 'cut-in-half' procedure until he has what he needs, and any remaining sheets are always placed back in the envelope.

Excluding the first and last batch of the week, find the expected number of times (during each week) that the foreman finds a single sheet of paper in the envelope.

Give your answer rounded to six decimal places using the format `x.xxxxxx`.

### --tests--

`expectedValueProblem()` should return `0.464399`.

```js
assert.strictEqual(expectedValueProblem(), 0.464399);
```

## 51

### --description--

There are several ways to write the number $\frac{1}{2}$ as a sum of inverse squares using distinct integers.

For instance, the numbers {2,3,4,5,7,12,15,20,28,35} can be used:

$$\frac{1}{2} = \frac{1}{2^2} + \frac{1}{3^2} + \frac{1}{4^2} + \frac{1}{5^2} + \frac{1}{7^2} + \frac{1}{{12}^2} + \frac{1}{{15}^2} + \frac{1}{{20}^2} + \frac{1}{{28}^2} + \frac{1}{{35}^2}$$

In fact, only using integers between 2 and 45 inclusive, there are exactly three ways to do it, the remaining two being: {2,3,4,6,7,9,10,20,28,35,36,45} and {2,3,4,6,7,9,12,15,28,30,35,36,45}.

How many ways are there to write the number $\frac{1}{2}$ as a sum of inverse squares using distinct integers between 2 and 80 inclusive?

### --tests--

`sumInverseSquares()` should return `301`.

```js
assert.strictEqual(sumInverseSquares(), 301);
```

## 52

### --description--

As we all know the equation $x^2 = -1$ has no solutions for real $x$.

If we however introduce the imaginary number $i$ this equation has two solutions: $x = i$ and $x = -i$.

If we go a step further the equation ${(x - 3)}^2 = -4$ has two complex solutions: $x = 3 + 2i$ and $x = 3 - 2i$, which are called each others' complex conjugate.

Numbers of the form $a + bi$ are called complex numbers.

In general $a + bi$ and $a − bi$ are each other's complex conjugate. A Gaussian Integer is a complex number $a + bi$ such that both $a$ and $b$ are integers.

The regular integers are also Gaussian integers (with $b = 0$).

To distinguish them from Gaussian integers with $b ≠ 0$ we call such integers "rational integers."

A Gaussian integer is called a divisor of a rational integer $n$ if the result is also a Gaussian integer.

If for example we divide 5 by $1 + 2i$ we can simplify in the following manner:

Multiply numerator and denominator by the complex conjugate of $1 + 2i$: $1 − 2i$.

The result is:

$$\frac{5}{1 + 2i} = \frac{5}{1 + 2i} \frac{1 - 2i}{1 - 2i} = \frac{5(1 - 2i)}{1 - {(2i)}^2} = \frac{5(1 - 2i)}{1 - (-4)} = \frac{5(1 - 2i)}{5} = 1 - 2i$$

So $1 + 2i$ is a divisor of 5.

Note that $1 + i$ is not a divisor of 5 because:

$$\frac{5}{1 + i} = \frac{5}{2} - \frac{5}{2}i$$

Note also that if the Gaussian Integer ($a + bi$) is a divisor of a rational integer $n$, then its complex conjugate ($a − bi$) is also a divisor of $n$. In fact, 5 has six divisors such that the real part is positive: {1, 1 + 2i, 1 − 2i, 2 + i, 2 − i, 5}.

The following is a table of all of the divisors for the first five positive rational integers:

| n | Gaussian integer divisors with positive real part | Sum s(n) of these divisors |
|---|---------------------------------------------------|----------------------------|
| 1 | 1                                                 | 1                          |
| 2 | 1, 1 + i, 1 - i, 2                                | 5                          |
| 3 | 1, 3                                              | 4                          |
| 4 | 1, 1 + i, 1 - i, 2, 2 + 2i, 2 - 2i, 4             | 13                         |
| 5 | 1, 1 + 2i, 1 - 2i, 2 + i, 2 - i, 5                | 12                         |

For divisors with positive real parts, then, we have: $\displaystyle\sum_{n=1}^5 s(n) = 35$.

For $1 ≤ n ≤ {10}^5$, $\displaystyle\sum_{n = 1}^{{10}^5} s(n) = 17924657155$.

What is $\displaystyle\sum_{n=1}^{{10}^8} s(n)$?

### --tests--

`sumGaussianIntegers()` should return `17971254122360636`.

```js
assert.strictEqual(sumGaussianIntegers(), 17971254122360636);
```

## 53

### --description--

A triangular pyramid is constructed using spherical balls so that each ball rests on exactly three balls of the next lower level.

<img class="img-responsive center-block" alt="triangular pyramid constructed using spherical balls with four levels" src="https://cdn.freecodecamp.org/curriculum/project-euler/exploring-pascals-pyramid.png" style="background-color: white; padding: 10px;">

Then, we calculate the number of paths leading from the apex to each position: A path starts at the apex and progresses downwards to any of the three spheres directly below the current position. Consequently, the number of paths to reach a certain position is the sum of the numbers immediately above it (depending on the position, there are up to three numbers above it).

The result is Pascal's pyramid and the numbers at each level n are the coefficients of the trinomial expansion ${(x + y + z)}^n$.

How many coefficients in the expansion of ${(x + y + z)}^{200000}$ are multiples of ${10}^{12}$?

### --tests--

`pascalsPyramid()` should return `479742450`.

```js
assert.strictEqual(pascalsPyramid(), 479742450);
```

## 54

### --description--

An electric circuit uses exclusively identical capacitors of the same value C.

The capacitors can be connected in series or in parallel to form sub-units, which can then be connected in series or in parallel with other capacitors or other sub-units to form larger sub-units, and so on up to a final circuit.

Using this simple procedure and up to n identical capacitors, we can make circuits having a range of different total capacitances. For example, using up to $n = 3$ capacitors of $60 μF$ each, we can obtain the following 7 distinct total capacitance values:

<img class="img-responsive center-block" alt="example circuits having up to three capacitors, each of 60 μF" src="https://cdn.freecodecamp.org/curriculum/project-euler/counting-capacitor-circuits.gif" style="background-color: white; padding: 10px;">

If we denote by $D(n)$ the number of distinct total capacitance values we can obtain when using up to $n$ equal-valued capacitors and the simple procedure described above, we have: $D(1) = 1, D(2) = 3, D(3)=7, \ldots$

Find $D(18)$.

Reminder: When connecting capacitors $C_1$, $C_2$ etc in parallel, the total capacitance is $C_T = C_1 + C_2 + \cdots$, whereas when connecting them in series, the overall capacitance is given by: $\frac{1}{C_T} = \frac{1}{C_1} + \frac{1}{C_2} + \cdots$.

### --tests--

`capacitanceValues()` should return `3857447`.

```js
assert.strictEqual(capacitanceValues(), 3857447);
```

## 55

### --description--

Starting from zero the natural numbers are written down in base 10 like this:

0 1 2 3 4 5 6 7 8 9 10 11 12....

Consider the digit $d = 1$. After we write down each number n, we will update the number of ones that have occurred and call this number $f(n, 1)$. The first values for $f(n, 1)$, then, are as follows:

| $n$ | $f(n, 1)$ |
|-----|-----------|
| 0   | 0         |
| 1   | 1         |
| 2   | 1         |
| 3   | 1         |
| 4   | 1         |
| 5   | 1         |
| 6   | 1         |
| 7   | 1         |
| 8   | 1         |
| 9   | 1         |
| 10  | 2         |
| 11  | 4         |
| 12  | 5         |

Note that $f(n, 1)$ never equals 3.

So the first two solutions of the equation $f(n, 1) = n$ are $n = 0$ and $n = 1$. The next solution is $n = 199981$. In the same manner the function $f(n, d)$ gives the total number of digits d that have been written down after the number $n$ has been written.

In fact, for every digit $d ≠ 0$, 0 is the first solution of the equation $f(n, d) = n$. Let $s(d)$ be the sum of all the solutions for which $f(n, d) = n$.

You are given that $s(1) = 22786974071$. Find $\sum{s(d)}$ for $1 ≤ d ≤ 9$.

Note: if, for some $n$, $f(n, d) = n$ for more than one value of $d$ this value of $n$ is counted again for every value of $d$ for which $f(n, d) = n$.

### --tests--

`countingDigits()` should return `21295121502550`.

```js
assert.strictEqual(countingDigits(), 21295121502550);
```

## 56

### --description--

Consider the diophantine equation $\frac{1}{a} + \frac{1}{b} = \frac{p}{{10}^n}$ with $a$, $b$, $p$, $n$ positive integers and $a ≤ b$.

For $n = 1$ this equation has 20 solutions that are listed below:

$$\begin{array}{lllll}
  \frac{1}{1}  + \frac{1}{1}  = \frac{20}{10} & \frac{1}{1} + \frac{1}{2}  = \frac{15}{10}
& \frac{1}{1}  + \frac{1}{5}  = \frac{12}{10} & \frac{1}{1} + \frac{1}{10} = \frac{11}{10}
& \frac{1}{2}  + \frac{1}{2}  = \frac{10}{10} \\\\
  \frac{1}{2}  + \frac{1}{5}  = \frac{7}{10}   & \frac{1}{2} + \frac{1}{10} = \frac{6}{10}
& \frac{1}{3}  + \frac{1}{6}  = \frac{5}{10}   & \frac{1}{3} + \frac{1}{15} = \frac{4}{10}
& \frac{1}{4}  + \frac{1}{4}  = \frac{5}{10} \\\\
  \frac{1}{4}  + \frac{1}{4}  = \frac{5}{10}  & \frac{1}{5}  + \frac{1}{5}  = \frac{4}{10}
& \frac{1}{5}  + \frac{1}{10} = \frac{3}{10}  & \frac{1}{6}  + \frac{1}{30} = \frac{2}{10}
& \frac{1}{10} + \frac{1}{10} = \frac{2}{10} \\\\
  \frac{1}{11} + \frac{1}{110} = \frac{1}{10} & \frac{1}{12} + \frac{1}{60}  = \frac{1}{10}
& \frac{1}{14} + \frac{1}{35}  = \frac{1}{10} & \frac{1}{15} + \frac{1}{30}  = \frac{1}{10}
& \frac{1}{20} + \frac{1}{20}  = \frac{1}{10}
\end{array}$$

How many solutions has this equation for $1 ≤ n ≤ 9$?

### --tests--

`diophantineEquation()` should return `53490`.

```js
assert.strictEqual(diophantineEquation(), 53490);
```

## 57

### --description--

Taking three different letters from the 26 letters of the alphabet, character strings of length three can be formed.

Examples are 'abc', 'hat' and 'zyx'.

When we study these three examples we see that for 'abc' two characters come lexicographically after its neighbour to the left.

For 'hat' there is exactly one character that comes lexicographically after its neighbour to the left. For 'zyx' there are zero characters that come lexicographically after its neighbour to the left.

In all there are 10400 strings of length 3 for which exactly one character comes lexicographically after its neighbour to the left.

We now consider strings of $n ≤ 26$ different characters from the alphabet.

For every $n$, $p(n)$ is the number of strings of length $n$ for which exactly one character comes lexicographically after its neighbour to the left.

What is the maximum value of $p(n)$?

### --tests--

`lexicographicNeighbours()` should return `409511334375`.

```js
assert.strictEqual(lexicographicNeighbours(), 409511334375);
```

## 58

### --description--

A composite number can be factored many different ways.

For instance, not including multiplication by one, 24 can be factored in 7 distinct ways:

$$\begin{align}
  & 24 = 2 \times 2 \times 2 \times 3\\\\
  & 24 = 2 \times 3 \times 4  \\\\
  & 24 = 2 \times 2 \times 6  \\\\
  & 24 = 4 \times 6    \\\\
  & 24 = 3 \times 8    \\\\
  & 24 = 2 \times 12   \\\\
  & 24 = 24
\end{align}$$

Recall that the digital root of a number, in base 10, is found by adding together the digits of that number, and repeating that process until a number arrives at less than 10. Thus the digital root of 467 is 8.

We shall call a Digital Root Sum (DRS) the sum of the digital roots of the individual factors of our number. The chart below demonstrates all of the DRS values for 24.

| Factorisation | Digital Root Sum |
|---------------|------------------|
|    2x2x2x3    |        9         |
|     2x3x4     |        9         |
|     2x2x6     |        10        |
|      4x6      |        10        |
|      3x8      |        11        |
|      2x12     |        5         |
|      24       |        6         |

The maximum Digital Root Sum of 24 is 11. The function $mdrs(n)$ gives the maximum Digital Root Sum of $n$. So $mdrs(24) = 11$.

Find $\sum{mdrs(n)}$ for $1 &lt; n &lt; 1,000,000$.

### --tests--

`euler159()` should return `14489159`.

```js
assert.strictEqual(euler159(), 14489159);
```

## 59

### --description--

For any $N$, let $f(N)$ be the last five digits before the trailing zeroes in $N!$.

For example,

$$\begin{align}
  & 9! = 362880 \\; \text{so} \\; f(9) = 36288 \\\\
  & 10! = 3628800 \\; \text{so} \\; f(10) = 36288 \\\\
  & 20! = 2432902008176640000 \\; \text{so} \\; f(20) = 17664
\end{align}$$

Find $f(1,000,000,000,000)$

### --tests--

`factorialTrailingDigits()` should return `16576`.

```js
assert.strictEqual(factorialTrailingDigits(), 16576);
```

## 60

### --description--

A triomino is a shape consisting of three squares joined via the edges.

There are two basic forms:

<img class="img-responsive center-block" alt="two basic triominoes forms" src="https://cdn.freecodecamp.org/curriculum/project-euler/triominoes-1.gif" style="background-color: white; padding: 10px;">

If all possible orientations are taken into account there are six:

<img class="img-responsive center-block" alt="triominoes forms including orientation" src="https://cdn.freecodecamp.org/curriculum/project-euler/triominoes-2.gif" style="background-color: white; padding: 10px;">

Any n by m grid for which nxm is divisible by 3 can be tiled with triominoes. If we consider tilings that can be obtained by reflection or rotation from another tiling as different there are 41 ways a 2 by 9 grid can be tiled with triominoes:

<img class="img-responsive center-block" alt="animation showing 41 ways of filling 2x9 grid with triominoes" src="https://cdn.freecodecamp.org/curriculum/project-euler/triominoes-3.gif" style="background-color: white; padding: 10px;">

In how many ways can a 9 by 12 grid be tiled in this way by triominoes?

### --tests--

`triominoes()` should return `20574308184277972`.

```js
assert.strictEqual(triominoes(), 20574308184277972);
```

## 61

### --description--

In the hexadecimal number system numbers are represented using 16 different digits:

$$0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F$$

The hexadecimal number AF when written in the decimal number system equals $10 \times 16 + 15 = 175$.

In the 3-digit hexadecimal numbers 10A, 1A0, A10, and A01 the digits 0,1 and A are all present.

Like numbers written in base ten we write hexadecimal numbers without leading zeroes.

How many hexadecimal numbers containing at most sixteen hexadecimal digits exist with all of the digits 0,1, and A present at least once?

Give your answer with hexadecimal number as a string.

**Note:** (A,B,C,D,E and F in upper case, without any leading or trailing code that marks the number as hexadecimal and without leading zeroes , e.g. 1A3F and not: 1a3f and not 0x1a3f and not $1A3F and not #1A3F and not 0000001A3F)

### --tests--

`hexadecimalNumbers()` should return a string.

```js
assert(typeof hexadecimalNumbers() === 'string');
```

`hexadecimalNumbers()` should return the string `3D58725572C62302`.

```js
assert.strictEqual(hexadecimalNumbers(), '3D58725572C62302');
```

## 62

### --description--

Consider an equilateral triangle in which straight lines are drawn from each vertex to the middle of the opposite side, such as in the size 1 triangle in the sketch below.

<img class="img-responsive center-block" alt="triangles with size 1 and size 2" src="https://cdn.freecodecamp.org/curriculum/project-euler/cross-hatched-triangles.gif" style="background-color: white; padding: 10px;">

Sixteen triangles of either different shape or size or orientation or location can now be observed in that triangle. Using size 1 triangles as building blocks, larger triangles can be formed, such as the size 2 triangle in the above sketch. One-hundred and four triangles of either different shape or size or orientation or location can now be observed in that size 2 triangle.

It can be observed that the size 2 triangle contains 4 size 1 triangle building blocks. A size 3 triangle would contain 9 size 1 triangle building blocks and a size $n$ triangle would thus contain $n^2$ size 1 triangle building blocks.

If we denote $T(n)$ as the number of triangles present in a triangle of size $n$, then

$$\begin{align}
  & T(1) = 16 \\\\
  & T(2) = 104
\end{align}$$

Find $T(36)$.

### --tests--

`crossHatchedTriangles()` should return `343047`.

```js
assert.strictEqual(crossHatchedTriangles(), 343047);
```

## 63

### --description--

How many 20 digit numbers $n$ (without any leading zero) exist such that no three consecutive digits of $n$ have a sum greater than 9?

### --tests--

`consecutiveDigitsSum()` should return `378158756814587`.

```js
assert.strictEqual(consecutiveDigitsSum(), 378158756814587);
```

## 64

### --description--

A segment is uniquely defined by its two endpoints. By considering two line segments in plane geometry there are three possibilities: the segments have zero points, one point, or infinitely many points in common.

Moreover when two segments have exactly one point in common it might be the case that that common point is an endpoint of either one of the segments or of both. If a common point of two segments is not an endpoint of either of the segments it is an interior point of both segments.

We will call a common point $T$ of two segments $L_1$ and $L_2$ a true intersection point of $L_1$ and $L_2$ if $T$ is the only common point of $L_1$ and $L_2$ and $T$ is an interior point of both segments.

Consider the three segments $L_1$, $L_2$, and $L_3$:

$$\begin{align}
  & L_1: (27, 44) \\;\text{to}\\; (12, 32) \\\\
  & L_2: (46, 53) \\;\text{to}\\; (17, 62) \\\\
  & L_3: (46, 70) \\;\text{to}\\; (22, 40) \\\\
\end{align}$$

It can be verified that line segments $L_2$ and $L_3$ have a true intersection point. We note that as the one of the end points of $L_3$: (22, 40) lies on $L_1$ this is not considered to be a true point of intersection. $L_1$ and $L_2$ have no common point. So among the three line segments, we find one true intersection point.

Now let us do the same for 5000 line segments. To this end, we generate 20000 numbers using the so-called "Blum Blum Shub" pseudo-random number generator.

$$\begin{align}
  & s_0 = 290797 \\\\
  & s_{n + 1} = s_n × s_n (\text{modulo}\\; 50515093) \\\\
  & t_n = s_n (\text{modulo}\\; 500) \\\\
\end{align}$$

To create each line segment, we use four consecutive numbers $t_n$. That is, the first line segment is given by:

($_t$1, $t_2$) to ($t_3$, $t_4$)

The first four numbers computed according to the above generator should be: 27, 144, 12 and 232. The first segment would thus be (27, 144) to (12, 232).

How many distinct true intersection points are found among the 5000 line segments?

### --tests--

`distinctIntersections()` should return `2868868`.

```js
assert.strictEqual(distinctIntersections(), 2868868);
```

## 65

### --description--

A 4x4 grid is filled with digits $d$, $0 ≤ d ≤ 9$.

It can be seen that in the grid

$$\begin{array}{}
  6 & 3 & 3 & 0 \\\\
  5 & 0 & 4 & 3 \\\\
  0 & 7 & 1 & 4 \\\\
  1 & 2 & 4 & 5
\end{array}$$

the sum of each row and each column has the value 12. Moreover the sum of each diagonal is also 12.

In how many ways can you fill a 4x4 grid with the digits $d$, $0 ≤ d ≤ 9$ so that each row, each column, and both diagonals have the same sum?

### --tests--

`crissCross()` should return `7130034`.

```js
assert.strictEqual(crissCross(), 7130034);
```

## 66

### --description--

For two positive integers $a$ and $b$, the Ulam sequence $U(a,b)$ is defined by ${U{(a,b)}\_1} = a$, ${U{(a,b)}\_2} = b$ and for $k > 2$, ${U{(a,b)}\_k}$ is the smallest integer greater than ${U{(a,b)}\_{(k-1)}}$ which can be written in exactly one way as the sum of two distinct previous members of $U(a,b)$.

For example, the sequence $U(1,2)$ begins with

$$1, 2, 3 = 1 + 2, 4 = 1 + 3, 6 = 2 + 4, 8 = 2 + 6, 11 = 3 + 8$$

5 does not belong to it because $5 = 1 + 4 = 2 + 3$ has two representations as the sum of two previous members, likewise $7 = 1 + 6 = 3 + 4$.

Find $\sum {U(2, 2n + 1)_k}$ for $2 ≤ n ≤ 10$, where $k = {10}^{11}$.

### --tests--

`ulamSequences()` should return `3916160068885`.

```js
assert.strictEqual(ulamSequences(), 3916160068885);
```

## 67

### --description--

Consider the number 142857. We can right-rotate this number by moving the last digit (7) to the front of it, giving us 714285.

It can be verified that $714285 = 5 × 142857$.

This demonstrates an unusual property of 142857: it is a divisor of its right-rotation.

For integer number of digits $a$ and $b$, find the last 5 digits of the sum of all integers $n$, $10^a &lt; n &lt; 10^b$, that have this property.

### --tests--

`numberRotations(2, 10)` should return `98311`.

```js
assert.strictEqual(numberRotations(2, 10), 98311);
```

`numberRotations(2, 100)` should return `59206`.

```js
assert.strictEqual(numberRotations(2, 100), 59206);
```

## 68

### --description--

Define $f(0)=1$ and $f(n)$ to be the number of different ways $n$ can be expressed as a sum of integer powers of 2 using each power no more than twice.

For example, $f(10)=5$ since there are five different ways to express 10:

$$\begin{align}
  & 1 + 1 + 8 \\\\
  & 1 + 1 + 4 + 4 \\\\
  & 1 + 1 + 2 + 2 + 4 \\\\
  & 2 + 4 + 4 \\\\
  & 2 + 8
\end{align}$$

What is $f({10}^{25})$?

### --tests--

`numberOfWaysToExpress()` should return `178653872807`.

```js
assert.strictEqual(numberOfWaysToExpress(), 178653872807);
```

## 69

### --description--

Take the number 6 and multiply it by each of 1273 and 9854:

$$\begin{align}
  & 6 × 1273 = 7638 \\\\
  & 6 × 9854 = 59124 \\\\
\end{align}$$

By concatenating these products we get the 1 to 9 pandigital 763859124. We will call 763859124 the "concatenated product of 6 and (1273, 9854)". Notice too, that the concatenation of the input numbers, 612739854, is also 1 to 9 pandigital.

The same can be done for 0 to 9 pandigital numbers.

What is the largest 0 to 9 pandigital 10-digit concatenated product of an integer with two or more other integers, such that the concatenation of the input numbers is also a 0 to 9 pandigital 10-digit number?

### --tests--

`largestPandigital()` should return `9857164023`.

```js
assert.strictEqual(largestPandigital(), 9857164023);
```

## 70

### --description--

For a positive integer $n$, let $f(n)$ be the sum of the squares of the digits (in base 10) of $n$, e.g.

$$\begin{align}
  & f(3) = 3^2 = 9 \\\\
  & f(25) = 2^2 + 5^2 = 4 + 25 = 29 \\\\
  & f(442) = 4^2 + 4^2 + 2^2 = 16 + 16 + 4 = 36 \\\\
\end{align}$$

Find the last nine digits of the sum of all $n$, $0 &lt; n &lt; {10}^{20}$, such that $f(n)$ is a perfect square.

### --tests--

`lastDigitsSumOfPerfectSquare()` should return `142989277`.

```js
assert.strictEqual(lastDigitsSumOfPerfectSquare(), 142989277);
```

## 71

### --description--

How many 18-digit numbers $n$ (without leading zeros) are there such that no digit occurs more than three times in $n$?

### --tests--

`numbersWithRepeatedDigits()` should return `227485267000992000`.

```js
assert.strictEqual(numbersWithRepeatedDigits(), 227485267000992000);
```

## 72

### --description--

We shall define a square lamina to be a square outline with a square "hole" so that the shape possesses vertical and horizontal symmetry. For example, using exactly thirty-two square tiles we can form two different square laminae:

<img class="img-responsive center-block" alt="two square lamina with holes 2x2 and 7x7" src="https://cdn.freecodecamp.org/curriculum/project-euler/using-up-to-one-million-tiles-how-many-different-hollow-square-laminae-can-be-formed.gif" style="background-color: white; padding: 10px;">

With one-hundred tiles, and not necessarily using all of the tiles at one time, it is possible to form forty-one different square laminae. Using up to one million tiles how many different square laminae can be formed?

### --tests--

`differentHollowSquareLaminae()` should return `1572729`.

```js
assert.strictEqual(differentHollowSquareLaminae(), 1572729);
```

## 73

### --description--

We shall define a square lamina to be a square outline with a square "hole" so that the shape possesses vertical and horizontal symmetry.

Given eight tiles it is possible to form a lamina in only one way: 3x3 square with a 1x1 hole in the middle. However, using thirty-two tiles it is possible to form two distinct laminae.

<img class="img-responsive center-block" alt="two square lamina with holes 2x2 and 7x7" src="https://cdn.freecodecamp.org/curriculum/project-euler/using-up-to-one-million-tiles-how-many-different-hollow-square-laminae-can-be-formed.gif" style="background-color: white; padding: 10px;">

If $t$ represents the number of tiles used, we shall say that $t = 8$ is type $L(1)$ and $t = 32$ is type $L(2)$.

Let $N(n)$ be the number of $t ≤ 1000000$ such that $t$ is type $L(n)$; for example, $N(15) = 832$.

What is $\sum N(n)$ for $1 ≤ n ≤ 10$?

### --tests--

`hollowSquareLaminaeDistinctArrangements()` should return `209566`.

```js
assert.strictEqual(hollowSquareLaminaeDistinctArrangements(), 209566);
```

## 74

### --description--

Define $f(0) = 1$ and $f(n)$ to be the number of ways to write $n$ as a sum of powers of 2 where no power occurs more than twice.

For example, $f(10) = 5$ since there are five different ways to express 10:

$$10 = 8 + 2 = 8 + 1 + 1 = 4 + 4 + 2 = 4 + 2 + 2 + 1 + 1 = 4 + 4 + 1 + 1$$

It can be shown that for every fraction $\frac{p}{q}\\; (p>0, q>0)$ there exists at least one integer $n$ such that $\frac{f(n)}{f(n - 1)} = \frac{p}{q}$.

For instance, the smallest $n$ for which $\frac{f(n)}{f(n - 1)} = \frac{13}{17}$ is 241. The binary expansion of 241 is 11110001.

Reading this binary number from the most significant bit to the least significant bit there are 4 one's, 3 zeroes and 1 one. We shall call the string 4,3,1 the Shortened Binary Expansion of 241.

Find the Shortened Binary Expansion of the smallest $n$ for which

$$\frac{f(n)}{f(n - 1)} = \frac{123456789}{987654321}$$

Give your answer as a string with comma separated integers, without any whitespaces.

### --tests--

`shortenedBinaryExpansionOfNumber()` should return a string.

```js
assert(typeof shortenedBinaryExpansionOfNumber() === 'string');
```

`shortenedBinaryExpansionOfNumber()` should return the string `1,13717420,8`.

```js
assert.strictEqual(shortenedBinaryExpansionOfNumber(), '1,13717420,8');
```

## 75

### --description--

The four right-angled triangles with sides (9,12,15), (12,16,20), (5,12,13) and (12,35,37) all have one of the shorter sides (catheti) equal to 12. It can be shown that no other integer sided right-angled triangle exists with one of the catheti equal to 12.

Find the smallest integer that can be the length of a cathetus of exactly 47547 different integer sided right-angled triangles.

### --tests--

`trianglesSharingCathetus()` should return `96818198400000`.

```js
assert.strictEqual(trianglesSharingCathetus(), 96818198400000);
```

## 76

### --description--

Let ABCD be a convex quadrilateral, with diagonals AC and BD. At each vertex the diagonal makes an angle with each of the two sides, creating eight corner angles.

<img class="img-responsive center-block" alt="convex quadrilateral ABCD, with diagonals AC and BD" src="https://cdn.freecodecamp.org/curriculum/project-euler/integer-angled-quadrilaterals.gif" style="background-color: white; padding: 10px;">

For example, at vertex A, the two angles are CAD, CAB.

We call such a quadrilateral for which all eight corner angles have integer values when measured in degrees an "integer angled quadrilateral". An example of an integer angled quadrilateral is a square, where all eight corner angles are 45°. Another example is given by DAC = 20°, BAC = 60°, ABD = 50°, CBD = 30°, BCA = 40°, DCA = 30°, CDB = 80°, ADB = 50°.

What is the total number of non-similar integer angled quadrilaterals?

**Note:** In your calculations you may assume that a calculated angle is integral if it is within a tolerance of ${10}^{-9}$ of an integer value.

### --tests--

`integerAngledQuadrilaterals()` should return `129325`.

```js
assert.strictEqual(integerAngledQuadrilaterals(), 129325);
```

## 77

### --description--

Consider the number 45656.

It can be seen that each pair of consecutive digits of 45656 has a difference of one.

A number for which every pair of consecutive digits has a difference of one is called a step number.

A pandigital number contains every decimal digit from 0 to 9 at least once.

How many pandigital step numbers less than ${10}^{40}$ are there?

### --tests--

`stepNumbers()` should return `126461847755`.

```js
assert.strictEqual(stepNumbers(), 126461847755);
```

## 78

### --description--

Find the number of integers $1 &lt; n &lt; {10}^7$, for which $n$ and $n + 1$ have the same number of positive divisors. For example, 14 has the positive divisors 1, 2, 7, 14 while 15 has 1, 3, 5, 15.

### --tests--

`consecutivePositiveDivisors()` should return `986262`.

```js
assert.strictEqual(consecutivePositiveDivisors(), 986262);
```

## 79

### --description--

For any integer $n$, consider the three functions

$$\begin{align}
  & f_{1,n}(x,y,z) = x^{n + 1} + y^{n + 1} − z^{n + 1}\\\\
  & f_{2,n}(x,y,z) = (xy + yz + zx) \times (x^{n - 1} + y^{n - 1} − z^{n - 1})\\\\
  & f_{3,n}(x,y,z) = xyz \times (x^{n - 2} + y^{n - 2} − z^{n - 2})
\end{align}$$

and their combination

$$\begin{align}
  & f_n(x,y,z) = f_{1,n}(x,y,z) + f_{2,n}(x,y,z) − f_{3,n}(x,y,z)
\end{align}$$

We call $(x,y,z)$ a golden triple of order $k$ if $x$, $y$, and $z$ are all rational numbers of the form $\frac{a}{b}$ with $0 &lt; a &lt; b ≤ k$ and there is (at least) one integer $n$, so that $f_n(x,y,z) = 0$.

Let $s(x,y,z) = x + y + z$.

Let $t = \frac{u}{v}$ be the sum of all distinct $s(x,y,z)$ for all golden triples $(x,y,z)$ of order 35. All the $s(x,y,z)$ and $t$ must be in reduced form.

Find $u + v$.

### --tests--

`rationalZeros()` should return `285196020571078980`.

```js
assert.strictEqual(rationalZeros(), 285196020571078980);
```

## 80

### --description--

Having three black objects $B$ and one white object $W$ they can be grouped in 7 ways like this:

$$(BBBW)\\;(B,BBW)\\;(B,B,BW)\\;(B,B,B,W)\\;(B,BB,W)\\;(BBB,W)\\;(BB,BW)$$

In how many ways can sixty black objects $B$ and forty white objects $W$ be thus grouped?

### --tests--

`colorsGrouping()` should return `83735848679360670`.

```js
assert.strictEqual(colorsGrouping(), 83735848679360670);
```

## 81

### --description--

The RSA encryption is based on the following procedure:

Generate two distinct primes `p` and `q`.
Compute `n=p*q` and `φ=(p-1)(q-1)`.
Find an integer `e`, `1 < e < φ`, such that `gcd(e,φ) = 1`

A message in this system is a number in the interval `[0,n-1]`.
A text to be encrypted is then somehow converted to messages (numbers in the interval `[0,n-1]`).
To encrypt the text, for each message, `m`, c=m<sup>e</sup> mod n is calculated.

To decrypt the text, the following procedure is needed: calculate `d` such that `ed=1 mod φ`, then for each encrypted message, `c`, calculate m=c<sup>d</sup> mod n.

There exist values of `e` and `m` such that m<sup>e</sup> mod n = m.
We call messages `m` for which m<sup>e</sup> mod n=m unconcealed messages.

An issue when choosing `e` is that there should not be too many unconcealed messages.
For instance, let `p=19` and `q=37`.
Then `n=19*37=703` and `φ=18*36=648`.
If we choose `e=181`, then, although `gcd(181,648)=1` it turns out that all possible messages
m `(0≤m≤n-1)` are unconcealed when calculating m<sup>e</sup> mod n.
For any valid choice of `e` there exist some unconcealed messages.
It's important that the number of unconcealed messages is at a minimum.

For any given `p` and `q`, find the sum of all values of `e`, `1 < e < φ(p,q)` and `gcd(e,φ)=1`, so that the number of unconcealed messages for this value of `e` is at a minimum.

### --tests--

`RSAEncryption` should be a function.

```js
assert(typeof RSAEncryption === 'function')
```

`RSAEncryption` should return a number.

```js
assert.strictEqual(typeof RSAEncryption(19, 37), 'number');
```

`RSAEncryption(19, 37)` should return `17766`.

```js
assert.strictEqual(RSAEncryption(19, 37), 17766);
```

`RSAEncryption(283, 409)` should return `466196580`.

```js
assert.strictEqual(RSAEncryption(283, 409), 466196580);
```

`RSAEncryption(1009, 3643)` should return `399788195976`.

```js
assert.strictEqual(RSAEncryption(19, 37), 17766);
```

## 82

### --description--

Let $N$ be a positive integer and let $N$ be split into $k$ equal parts, $r = \frac{N}{k}$, so that $N = r + r + \cdots + r$.

Let $P$ be the product of these parts, $P = r × r × \cdots × r = r^k$.

For example, if 11 is split into five equal parts, 11 = 2.2 + 2.2 + 2.2 + 2.2 + 2.2, then $P = {2.2}^5 = 51.53632$.

Let $M(N) = P_{max}$ for a given value of $N$.

It turns out that the maximum for $N = 11$ is found by splitting eleven into four equal parts which leads to $P_{max} = {(\frac{11}{4})}^4$; that is, $M(11) = \frac{14641}{256} = 57.19140625$, which is a terminating decimal.

However, for $N = 8$ the maximum is achieved by splitting it into three equal parts, so $M(8) = \frac{512}{27}$, which is a non-terminating decimal.

Let $D(N) = N$ if $M(N)$ is a non-terminating decimal and $D(N) = -N$ if $M(N)$ is a terminating decimal.

For example, $\sum D(N)$ for $5 ≤ N ≤ 100$ is 2438.

Find $\sum D(N)$ for $5 ≤ N ≤ 10000$.

### --tests--

`maximumProductOfParts()` should return `48861552`.

```js
assert.strictEqual(maximumProductOfParts(), 48861552);
```

## 83

### --description--

Consider the set $I_r$ of points $(x,y)$ with integer coordinates in the interior of the circle with radius $r$, centered at the origin, i.e. $x^2 + y^2 &lt; r^2$.

For a radius of 2, $I_2$ contains the nine points (0,0), (1,0), (1,1), (0,1), (-1,1), (-1,0), (-1,-1), (0,-1) and (1,-1). There are eight triangles having all three vertices in $I_2$ which contain the origin in the interior. Two of them are shown below, the others are obtained from these by rotation.

<img class="img-responsive center-block" alt="circle with radius 2, centered at the origin, with nine marked points and two triangles - (-1,0), (0,1), (1,-1) and (-1,1), (0,-1), (1,1)" src="https://cdn.freecodecamp.org/curriculum/project-euler/triangles-containing-the-origin.gif" style="background-color: white; padding: 10px;">

For a radius of 3, there are 360 triangles containing the origin in the interior and having all vertices in $I_3$ and for $I_5$ the number is 10600.

How many triangles are there containing the origin in the interior and having all three vertices in $I_{105}$?

### --tests--

`trianglesContainingOrigin()` should return `1725323624056`.

```js
assert.strictEqual(trianglesContainingOrigin(), 1725323624056);
```

## 84

### --description--

The game Number Mind is a variant of the well known game Master Mind.

Instead of coloured pegs, you have to guess a secret sequence of digits. After each guess you're only told in how many places you've guessed the correct digit. So, if the sequence was 1234 and you guessed 2036, you'd be told that you have one correct digit; however, you would NOT be told that you also have another digit in the wrong place.

For instance, given the following guesses for a 5-digit secret sequence,

$$\begin{align}
  & 90342 ;2\\;\text{correct}\\\\
  & 70794 ;0\\;\text{correct}\\\\
  & 39458 ;2\\;\text{correct}\\\\
  & 34109 ;1\\;\text{correct}\\\\
  & 51545 ;2\\;\text{correct}\\\\
  & 12531 ;1\\;\text{correct}
\end{align}$$

The correct sequence 39542 is unique.

Based on the following guesses,

$$\begin{align}
  & 5616185650518293 ;2\\;\text{correct}\\\\
  & 3847439647293047 ;1\\;\text{correct}\\\\
  & 5855462940810587 ;3\\;\text{correct}\\\\
  & 9742855507068353 ;3\\;\text{correct}\\\\
  & 4296849643607543 ;3\\;\text{correct}\\\\
  & 3174248439465858 ;1\\;\text{correct}\\\\
  & 4513559094146117 ;2\\;\text{correct}\\\\
  & 7890971548908067 ;3\\;\text{correct}\\\\
  & 8157356344118483 ;1\\;\text{correct}\\\\
  & 2615250744386899 ;2\\;\text{correct}\\\\
  & 8690095851526254 ;3\\;\text{correct}\\\\
  & 6375711915077050 ;1\\;\text{correct}\\\\
  & 6913859173121360 ;1\\;\text{correct}\\\\
  & 6442889055042768 ;2\\;\text{correct}\\\\
  & 2321386104303845 ;0\\;\text{correct}\\\\
  & 2326509471271448 ;2\\;\text{correct}\\\\
  & 5251583379644322 ;2\\;\text{correct}\\\\
  & 1748270476758276 ;3\\;\text{correct}\\\\
  & 4895722652190306 ;1\\;\text{correct}\\\\
  & 3041631117224635 ;3\\;\text{correct}\\\\
  & 1841236454324589 ;3\\;\text{correct}\\\\
  & 2659862637316867 ;2\\;\text{correct}
\end{align}$$

Find the unique 16-digit secret sequence.

### --tests--

`numberMind()` should return `4640261571849533`.

```js
assert.strictEqual(numberMind(), 4640261571849533);
```

## 85

### --description--

Here are the records from a busy telephone system with one million users:

| RecNr | Caller | Called |
|-------|--------|--------|
|   1   | 200007 | 100053 |
|   2   | 600183 | 500439 |
|   3   | 600863 | 701497 |
|  ...  |  ...   |  ...   |

The telephone number of the caller and the called number in record $n$ are $Caller(n) = S_{2n - 1}$ and $Called(n) = S_{2n}$ where ${S}_{1,2,3,\ldots}$ come from the "Lagged Fibonacci Generator":

For $1 ≤ k ≤ 55$, $S_k = [100003 - 200003k + 300007{k}^3]\\;(\text{modulo}\\;1000000)$

For $56 ≤ k$, $S_k = [S_{k - 24} + S_{k - 55}]\\;(\text{modulo}\\;1000000)$

If $Caller(n) = Called(n)$ then the user is assumed to have misdialled and the call fails; otherwise the call is successful.

From the start of the records, we say that any pair of users $X$ and $Y$ are friends if $X$ calls $Y$ or vice-versa. Similarly, $X$ is a friend of a friend of $Z$ if $X$ is a friend of $Y$ and $Y$ is a friend of $Z$; and so on for longer chains.

The Prime Minister's phone number is 524287. After how many successful calls, not counting misdials, will 99% of the users (including the PM) be a friend, or a friend of a friend etc., of the Prime Minister?

### --tests--

`connectednessOfANetwork()` should return `2325629`.

```js
assert.strictEqual(connectednessOfANetwork(), 2325629);
```

## 86

### --description--

A composite is a number containing at least two prime factors. For example, $15 = 3 × 5; 9 = 3 × 3; 12 = 2 × 2 × 3$.

There are ten composites below thirty containing precisely two, not necessarily distinct, prime factors: 4, 6, 9, 10, 14, 15, 21, 22, 25, 26.

How many composite integers, $n &lt; {10}^8$, have precisely two, not necessarily distinct, prime factors?

### --tests--

`semiPrimes()` should return `17427258`.

```js
assert.strictEqual(euler187(), 17427258);
```

## 87

### --description--

The hyperexponentiation or tetration of a number $a$ by a positive integer $b$, denoted by $a↑↑b$ or ${}^ba$, is recursively defined by:

$a↑↑1 = a$,

$a↑↑(k+1) = a^{(a↑↑k)}$.

Thus we have e.g. $3↑↑2 = 3^3 = 27$, hence $3↑↑3 = 3^{27} = 7625597484987$ and $3↑↑4$ is roughly ${10}^{3.6383346400240996 \times {10}^{12}}$. Find the last 8 digits of $1777↑↑1855$.

### --tests--

`hyperexponentation()` should return `95962097`.

```js
assert.strictEqual(hyperexponentation(), 95962097);
```

## 88

### --description--

Consider the following configuration of 64 triangles:

<img class="img-responsive center-block" alt="64 triangles arranged to create larger triangle with side length of 8 triangles" src="https://cdn.freecodecamp.org/curriculum/project-euler/tri-colouring-a-triangular-grid-1.gif" style="background-color: white; padding: 10px;">

We wish to colour the interior of each triangle with one of three colours: red, green or blue, so that no two neighbouring triangles have the same colour. Such a colouring shall be called valid. Here, two triangles are said to be neighbouring if they share an edge. Note: if they only share a vertex, then they are not neighbours.

For example, here is a valid colouring of the above grid:

<img class="img-responsive center-block" alt="colored grid of 64 triangles" src="https://cdn.freecodecamp.org/curriculum/project-euler/tri-colouring-a-triangular-grid-2.gif" style="background-color: white; padding: 10px;">

A colouring C' which is obtained from a colouring C by rotation or reflection is considered distinct from C unless the two are identical.

How many distinct valid colourings are there for the above configuration?

### --tests--

`triangularGridColoring()` should return `10834893628237824`.

```js
assert.strictEqual(triangularGridColoring(), 10834893628237824);
```

## 89

### --description--

Let $S_m = (x_1, x_2, \ldots, x_m)$ be the $m$-tuple of positive real numbers with $x_1 + x_2 + \cdots + x_m = m$ for which $P_m = x_1 \times {x_2}^2 \times \cdots \times {x_m}^m$ is maximised.

For example, it can be verified that $[P_{10}] = 4112$ ([ ] is the integer part function).

Find $\sum {[P_m]}$ for $2 ≤ m ≤ 15$.

### --tests--

`maximisingWeightedProduct()` should return `371048281`.

```js
assert.strictEqual(maximisingWeightedProduct(), 371048281);
```

## 90

### --description--

A particular school offers cash rewards to children with good attendance and punctuality. If they are absent for three consecutive days or late on more than one occasion then they forfeit their prize.

During an n-day period a trinary string is formed for each child consisting of L's (late), O's (on time), and A's (absent).

Although there are eighty-one trinary strings for a 4-day period that can be formed, exactly forty-three strings would lead to a prize:

```markup
OOOO OOOA OOOL OOAO OOAA OOAL OOLO OOLA OAOO OAOA
OAOL OAAO OAAL OALO OALA OLOO OLOA OLAO OLAA AOOO
AOOA AOOL AOAO AOAA AOAL AOLO AOLA AAOO AAOA AAOL
AALO AALA ALOO ALOA ALAO ALAA LOOO LOOA LOAO LOAA
LAOO LAOA LAAO
```

How many "prize" strings exist over a 30-day period?

### --tests--

`prizeStrings()` should return `1918080160`.

```js
assert.strictEqual(prizeStrings(), 1918080160);
```

## 91

### --description--

Let $x$ be a real number.

A best approximation to $x$ for the denominator bound $d$ is a rational number $\frac{r}{s}$ in reduced form, with $s ≤ d$, such that any rational number which is closer to $x$ than $\frac{r}{s}$ has a denominator larger than $d$:

$$|\frac{p}{q} - x| &lt; |\frac{r}{s} - x| ⇒ q > d$$

For example, the best approximation to $\sqrt{13}$ for the denominator bound $20$ is $\frac{18}{5}$ and the best approximation to $\sqrt{13}$ for the denominator bound $30$ is $\frac{101}{28}$.

Find the sum of all denominators of the best approximations to $\sqrt{n}$ for the denominator bound ${10}^{12}$, where $n$ is not a perfect square and $1 &lt; n ≤ 100000$.

### --tests--

`bestApproximations()` should return `57060635927998344`.

```js
assert.strictEqual(bestApproximations(), 57060635927998344);
```

## 92

### --description--

A positive integer $n$ is called squarefree, if no square of a prime divides $n$, thus 1, 2, 3, 5, 6, 7, 10, 11 are squarefree, but not 4, 8, 9, 12.

How many squarefree numbers are there below $2^{50}$?

### --tests--

`squarefreeNumbers()` should return `684465067343069`.

```js
assert.strictEqual(squarefreeNumbers(), 684465067343069);
```

## 93

### --description--

Consider graphs built with the units A:
<img class="img-responsive" alt="graph unit A" src="https://cdn.freecodecamp.org/curriculum/project-euler/coloured-configurations-1.png" style="display: inline-block; background-color: white; padding: 10px;">
 and B: <img class="img-responsive" alt="graph unit B" src="https://cdn.freecodecamp.org/curriculum/project-euler/coloured-configurations-2.png" style="display: inline-block; background-color: white; padding: 10px;">, where the units are glued along the vertical edges as in the graph <img class="img-responsive" alt="graph with four units glued along the vertical edges" src="https://cdn.freecodecamp.org/curriculum/project-euler/coloured-configurations-3.png" style="display: inline-block; background-color: white; padding: 10px;">.

A configuration of type $(a,b,c)$ is a graph thus built of $a$ units A and $b$ units B, where the graph's vertices are coloured using up to $c$ colours, so that no two adjacent vertices have the same colour. The compound graph above is an example of a configuration of type $(2,2,6)$, in fact of type $(2,2,c)$ for all $c ≥ 4$

Let $N(a,b,c)$ be the number of configurations of type $(a,b,c)$. For example, $N(1,0,3) = 24$, $N(0,2,4) = 92928$ and $N(2,2,3) = 20736$.

Find the last 8 digits of $N(25,75,1984)$.

### --tests--

`coloredConfigurations()` should return `61190912`.

```js
assert.strictEqual(coloredConfigurations(), 61190912);
```

## 94

### --description--

Let's call an integer sided triangle with exactly one angle of 60° a 60° triangle.

Let $r$ be the radius of the inscribed circle of such a 60° triangle.

There are 1234 60° triangles for which $r ≤ 100$.

Let $T(n)$ be the number of 60° triangles for which $r ≤ n$, so $T(100) = 1234$, $T(1000) = 22767$, and $T(10000) = 359912$.

Find $T(1053779)$.

### --tests--

`inscribedCirclesOfTriangles()` should return `75085391`.

```js
assert.strictEqual(inscribedCirclesOfTriangles(), 75085391);
```

## 95

### --description--

Build a triangle from all positive integers in the following way:

$$\begin{array}{rrr}
  &  1 \\\\
  &  \color{red}{2} &  \color{red}{3} \\\\
  &  4 & \color{red}{5} &  6 \\\\
  &  \color{red}{7} &  8 &  9 & 10 \\\\
  & \color{red}{11} & 12 & \color{red}{13} & 14 & 15  \\\\
  & 16 & \color{red}{17} & 18 & \color{red}{19} & 20 & 21 \\\\
  & 22 & \color{red}{23} & 24 & 25 & 26 & 27 & 28 \\\\
  & \color{red}{29} & 30 & \color{red}{31} & 32 & 33 & 34 & 35 & 36 \\\\
  & \color{red}{37} & 38 & 39 & 40 & \color{red}{41} & 42 & \color{red}{43} & 44 & 45 \\\\
  & 46 & \color{red}{47} & 48 & 49 & 50 & 51 & 52 & \color{red}{53} & 54 & 55 \\\\
  & 56 & 57 & 58 & \color{red}{59} & 60 & \color{red}{61} & 62 & 63 & 64 & 65 & 66 \\\\
  & \cdots
\end{array}$$

Each positive integer has up to eight neighbours in the triangle.

A set of three primes is called a prime triplet if one of the three primes has the other two as neighbours in the triangle.

For example, in the second row, the prime numbers 2 and 3 are elements of some prime triplet.

If row 8 is considered, it contains two primes which are elements of some prime triplet, i.e. 29 and 31. If row 9 is considered, it contains only one prime which is an element of some prime triplet: 37.

Define $S(n)$ as the sum of the primes in row $n$ which are elements of any prime triplet. Then $S(8) = 60$ and $S(9) = 37$.

You are given that $S(10000) = 950007619$.

Find $S(5678027) + S(7208785)$.

### --tests--

`primeTriplets()` should return `322303240771079940`.

```js
assert.strictEqual(primeTriplets(), 322303240771079940);
```

## 96

### --description--

Given is the function $f(x) = ⌊{2}^{30.403243784 - x^2}⌋ × {10}^{-9}$ ( ⌊ ⌋ is the floor-function), the sequence $u_n$ is defined by $u_0 = -1$ and $u_{n + 1} = f(u_n)$.

Find $u_n + u_{n + 1}$ for $n = {10}^{12}$. Give your answer with 9 digits after the decimal point.

### --tests--

`recursivelyDefinedSequence()` should return `1.710637717`.

```js
assert.strictEqual(recursivelyDefinedSequence(), 1.710637717);
```

## 97

### --description--

A best approximation to a real number $x$ for the denominator bound $d$ is a rational number $\frac{r}{s}$ (in reduced form) with $s ≤ d$, so that any rational number $\frac{p}{q}$ which is closer to $x$ than $\frac{r}{s}$ has $q > d$.

Usually the best approximation to a real number is uniquely determined for all denominator bounds. However, there are some exceptions, e.g. $\frac{9}{40}$ has the two best approximations $\frac{1}{4}$ and $\frac{1}{5}$ for the denominator bound $6$. We shall call a real number $x$ ambiguous, if there is at least one denominator bound for which $x$ possesses two best approximations. Clearly, an ambiguous number is necessarily rational.

How many ambiguous numbers $x = \frac{p}{q}$, $0 &lt; x &lt; \frac{1}{100}$, are there whose denominator $q$ does not exceed ${10}^8$?

### --tests--

`ambiguousNumbers()` should return `52374425`.

```js
assert.strictEqual(ambiguousNumbers(), 52374425);
```

## 98

### --description--

Three circles of equal radius are placed inside a larger circle such that each pair of circles is tangent to one another and the inner circles do not overlap. There are four uncovered "gaps" which are to be filled iteratively with more tangent circles.

<img class="img-responsive center-block" alt="a diagram of non-overlapping circles" src="https://cdn-media-1.freecodecamp.org/project-euler/199-circles-in-circles.gif" style="background-color: white; padding: 10px;">

At each iteration, a maximally sized circle is placed in each gap, which creates more gaps for the next iteration. After 3 iterations (pictured), there are 108 gaps and the fraction of the area which is not covered by circles is 0.06790342, rounded to eight decimal places.

What fraction of the area is not covered by circles after `n` iterations? Give your answer rounded to eight decimal places using the format x.xxxxxxxx .

### --tests--

`iterativeCirclePacking(10)` should return a number.

```js
assert(typeof iterativeCirclePacking(10) === 'number');
```

`iterativeCirclePacking(10)` should return `0.00396087`.

```js
assert.strictEqual(iterativeCirclePacking(10), 0.00396087);
```

`iterativeCirclePacking(3)` should return `0.06790342`.

```js
assert.strictEqual(iterativeCirclePacking(3), 0.06790342);
```

## 99

### --description--

We shall define a sqube to be a number of the form, ${p^2}{q^3}$, where $p$ and $q$ are distinct primes.

For example, $200 = {5^2}{2^3}$ or $120072949 = {{23}^2}{{61}^3}$.

The first five squbes are 72, 108, 200, 392, and 500.

Interestingly, 200 is also the first number for which you cannot change any single digit to make a prime; we shall call such numbers, prime-proof. The next prime-proof sqube which contains the contiguous sub-string `200` is 1992008.

Find the 200th prime-proof sqube containing the contiguous sub-string `200`.

### --tests--

`primeProofSqubeWithSubString()` should return `229161792008`.

```js
assert.strictEqual(primeProofSqubeWithSubString(), 229161792008);
```

## --fcc-end--
    